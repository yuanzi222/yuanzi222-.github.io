<!DOCTYPE HTML><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,maximum-scale=1,minimum-scale=1"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta http-equiv="Cache-Control" content="no-siteapp"><meta http-equiv="Cache-Control" content="no-transform"><meta name="renderer" content="webkit|ie-comp|ie-stand"><meta name="apple-mobile-web-app-capable" content="元子的博客"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=no,email=no,adress=no"><meta name="browsermode" content="application"><meta name="screen-orientation" content="portrait"><link rel="dns-prefetch" href="https://yuanzi222.com"><meta name="keywords" content="分布式"><meta name="description" content="分布式一致性问题首先我们先来看一个小例子：
假设某商城有一个商品库存剩10个，用户A想要买6个，用户B想要买5个，在理想状态下，用户A先买走了6了，库存减少6个还剩4个，此时用户B应该无法购买5..."><meta name="robots" content="all"><meta name="google" content="all"><meta name="googlebot" content="all"><meta name="verify" content="all"><title>分布式锁 | 元子的博客</title><link rel="alternate" href="/atom.xml" title="元子的博客" type="application/atom+xml"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7"><link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.5.0"><link rel="stylesheet" href="/css/style.css?rev=@@hash"></head></html><!--[if lte IE 8]><style>
    html{ font-size: 1em }
</style><![endif]--><!--[if lte IE 9]><div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div><![endif]--><body><header class="main-header" style="background-image:url(https://image.yuanzi222.com/blog/homeImages/banner.jpg)"><div class="main-header-box"> <a class="header-avatar" href="/" title="xueyya"><img src="https://image.yuanzi222.com/blog/homeImages/avatar.jpg" alt="logo头像" class="img-responsive center-block"></a><div class="branding"><h2> 记录学习的技能和遇到的问题</h2></div> <a href="https://github.com/yuanzi222" class="github-corner" aria-label="View source on Github" rel="external nofollow noopener noreferrer" target="_blank"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513;color:#fff;position:absolute;top:0;border:0;right:0" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style></div></header><nav class="main-navigation"><div class="container"><div class="row"><div class="col-sm-12"><div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav"><span class="sr-only"></span><i class="fa fa-bars"></i></span> <a class="navbar-brand" href="https://yuanzi222.com">元子的博客</a></div><div class="collapse navbar-collapse" id="main-menu"><ul class="menu"><li role="presentation" class="text-center"><a href="/"><i class="fa fa-home"></i> 首页</a></li><li role="presentation" class="text-center"><a href="/categories/Java"><i class="fa fa-th"></i> Java</a></li><li role="presentation" class="text-center"><a href="/archives/"><i class="fa fa-archive"></i> 时间轴</a></li><li role="presentation" class="text-center"><a href="/game/"><i class="fa fa-gamepad"></i> 轻松一刻</a></li><li role="presentation" class="text-center"><a href="/about"><i class="fa fa-user"></i> 关于我</a></li></ul></div></div></div></div></nav><section class="content-wrap"><div class="container"><div class="row"><main class="col-md-8 main-content m-post"><p id="process"></p><article class="post"><div class="post-head"><h1 id="分布式锁"> 分布式锁</h1><div class="post-meta"><span class="categories-meta fa-wrap"><i class="fa fa-folder-open-o"></i> 分类 <a class="category-link" href="/categories/Java/">Java</a></span><span class="fa-wrap"><i class="fa fa-tags"></i> <span class="tags-meta">标签 <a class="tag-link" href="/tags/分布式/">分布式</a></span></span><span class="fa-wrap"><i class="fa fa-calendar-o"></i> 发表日期 <span class="date-meta">2017/09/15</span></span><span class="fa-wrap"><i class="fa fa-eye"></i> 阅读数<span id="busuanzi_value_page_pv"></span></span><div class="post-symbolscount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> 本文字数 3.2k <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span> 阅读时长 3 分钟</div></div></div><div class="post-body post-content"><h1 id="分布式一致性问题"><a href="#分布式一致性问题" class="headerlink" title="分布式一致性问题"></a>分布式一致性问题</h1><p>首先我们先来看一个小例子：</p><p>假设某商城有一个商品库存剩10个，用户A想要买6个，用户B想要买5个，在理想状态下，用户A先买走了6了，库存减少6个还剩4个，此时用户B应该无法购买5个，给出数量不足的提示；而在真实情况下，用户A和B同时获取到商品剩10个，A买走6个，在A更新库存之前，B又买走了5个，此时B更新库存，商品还剩5个，这就是典型的电商“秒杀”活动。</p><p>从上述例子不难看出，在高并发情况下，如果不做处理将会出现各种不可预知的后果。那么在这种高并发多线程的情况下，解决问题最有效最普遍的方法就是给共享资源或对共享资源的操作加一把锁，来保证对资源的访问互斥。在Java JDK已经为我们提供了这样的锁，利用ReentrantLcok或者synchronized，即可达到资源互斥访问的目的。但是在分布式系统中，由于分布式系统的分布性，即多线程和多进程并且分布在不同机器中，这两种锁将失去原有锁的效果，需要我们自己实现分布式锁——分布式锁。</p><h1 id="分布式锁需要具备哪些条件"><a href="#分布式锁需要具备哪些条件" class="headerlink" title="分布式锁需要具备哪些条件"></a>分布式锁需要具备哪些条件</h1><ol><li><p>获取锁和释放锁的性能要好</p></li><li><p>判断是否获得锁必须是原子性的，否则可能导致多个请求都获取到锁</p></li><li><p>网络中断或宕机无法释放锁时，锁必须被清楚，不然会发生死锁</p></li><li><p>可重入一个线程中可以多次获取同一把锁，比如一个线程在执行一个带锁的方法，该方法中又调用了另一个需要相同锁的方法，则该线程可以直接执行调用的方法，而无需重新获得锁；</p></li></ol><p>5.阻塞锁和非阻塞锁，阻塞锁即没有获取到锁，则继续等待获取锁；非阻塞锁即没有获取到锁后，不继续等待，直接返回锁失败。</p><h1 id="分布式锁实现方式"><a href="#分布式锁实现方式" class="headerlink" title="分布式锁实现方式"></a>分布式锁实现方式</h1><h2 id="一、数据库锁"><a href="#一、数据库锁" class="headerlink" title="一、数据库锁"></a>一、数据库锁</h2><h3 id="1-基于MySQL锁表"><a href="#1-基于MySQL锁表" class="headerlink" title="1. 基于MySQL锁表"></a>1. 基于MySQL锁表</h3><p>该实现方式完全依靠数据库唯一索引来实现，当想要获得锁时，即向数据库中插入一条记录，释放锁时就删除这条记录。这种方式存在以下几个问题：</p><p>(1) 锁没有失效时间，解锁失败会导致死锁，其他线程无法再获取到锁，因为唯一索引insert都会返回失败。</p><p>(2) 只能是非阻塞锁，insert失败直接就报错了，无法进入队列进行重试</p><p>(3) 不可重入，同一线程在没有释放锁之前无法再获取到锁</p><h3 id="2-采用乐观锁增加版本号"><a href="#2-采用乐观锁增加版本号" class="headerlink" title="2. 采用乐观锁增加版本号"></a>2. 采用乐观锁增加版本号</h3><p>根据版本号来判断更新之前有没有其他线程更新过，如果被更新过，则获取锁失败。</p><h2 id="二、缓存锁"><a href="#二、缓存锁" class="headerlink" title="二、缓存锁"></a>二、缓存锁</h2><p>这里我们主要介绍几种基于redis实现的分布式锁：</p><h3 id="1-基于setnx、expire两个命令来实现"><a href="#1-基于setnx、expire两个命令来实现" class="headerlink" title="1. 基于setnx、expire两个命令来实现"></a>1. 基于setnx、expire两个命令来实现</h3><p>基于setnx（set if not exist）的特点，当缓存里key不存在时，才会去set，否则直接返回false。如果返回true则获取到锁，否则获取锁失败，为了防止死锁，我们再用expire命令对这个key设置一个超时时间来避免。但是这里看似完美，实则有缺陷，当我们setnx成功后，线程发生异常中断，expire还没来的及设置，那么就会产生死锁。</p><p>解决上述问题有两种方案</p><p>第一种是采用redis2.6.12版本以后的set，它提供了一系列选项</p><ul><li><p>EX seconds – 设置键key的过期时间，单位时秒</p></li><li><p>PX milliseconds – 设置键key的过期时间，单位时毫秒</p></li><li><p>NX – 只有键key不存在的时候才会设置key的值</p></li><li><p>XX – 只有键key存在的时候才会设置key的值</p></li></ul><p>第二种采用setnx()，get()，getset()实现，大体的实现过程如下：</p><p>(1) 线程Asetnx，值为超时的时间戳(t1)，如果返回true，获得锁。</p><p>(2) 线程B用get 命令获取t1，与当前时间戳比较，判断是否超时，没超时false，如果已超时执行步骤3</p><p>(3) 计算新的超时时间t2，使用getset命令返回t3(这个值可能其他线程已经修改过)，如果t1==t3,获得锁,如果t1!=t3说明锁被其他线程获取了</p><p>(4) 获取锁后，处理完业务逻辑，再去判断锁是否超时，如果没超时删除锁，如果已超时，不用处理（防止删除其他线程的锁）</p><h3 id="2-RedLock算法"><a href="#2-RedLock算法" class="headerlink" title="2. RedLock算法"></a>2. RedLock算法</h3><p>redlock算法是redis作者推荐的一种分布式锁实现方式，算法的内容如下：</p><p>(1) 获取当前时间；</p><p>(2) 尝试从5个相互独立redis客户端获取锁；</p><p>(3) 计算获取所有锁消耗的时间，当且仅当客户端从多数节点获取锁，并且获取锁的时间小于锁的有效时间，认为获得锁；</p><p>(4) 重新计算有效期时间，原有效时间减去获取锁消耗的时间；</p><p>(5) 删除所有实例的锁</p><p>redlock算法相对于单节点redis锁可靠性要更高，但是实现起来条件也较为苛刻。</p><p>(1) 必须部署5个节点才能让Redlock的可靠性更强。</p><p>(2) 需要请求5个节点才能获取到锁，通过Future的方式，先并发向5个节点请求，再一起获得响应结果，能缩短响应时间，不过还是比单节点redis锁要耗费更多时间。</p><p>然后由于必须获取到5个节点中的3个以上，所以可能出现获取锁冲突，即大家都获得了1-2把锁，结果谁也不能获取到锁，这个问题，redis作者借鉴了raft算法的精髓，通过冲突后在随机时间开始，可以大大降低冲突时间，但是这问题并不能很好的避免，特别是在第一次获取锁的时候，所以获取锁的时间成本增加了。</p><p>如果5个节点有2个宕机，此时锁的可用性会极大降低，首先必须等待这两个宕机节点的结果超时才能返回，另外只有3个节点，客户端必须获取到这全部3个节点的锁才能拥有锁，难度也加大了。</p><p>如果出现网络分区，那么可能出现客户端永远也无法获取锁的情况，介于这种情况，下面我们来看一种更可靠的分布式锁zookeeper锁。</p><p><img src="https://image.yuanzi222.com/blog/20170915/redLock.png" alt=""></p><h2 id="三、zookeeper分布式锁"><a href="#三、zookeeper分布式锁" class="headerlink" title="三、zookeeper分布式锁"></a>三、zookeeper分布式锁</h2><p>首先我们来了解一下zookeeper的特性，看看它为什么适合做分布式锁，</p><p>zookeeper是一个为分布式应用提供一致性服务的软件，它内部是一个分层的文件系统目录树结构，规定统一个目录下只能有一个唯一文件名。</p><p>数据模型：</p><ul><li><p>永久节点：节点创建后，不会因为会话失效而消失</p></li><li><p>临时节点：与永久节点相反，如果客户端连接失效，则立即删除节点</p></li><li><p>顺序节点：与上述两个节点特性类似，如果指定创建这类节点时，zk会自动在节点名后加一个数字后缀，并且是有序的。</p></li></ul><p>监视器（watcher）：</p><ul><li>当创建一个节点时，可以注册一个该节点的监视器，当节点状态发生改变时，watch被触发时，ZooKeeper将会向客户端发送且仅发送一条通知，因为watch只能被触发一次。</li></ul><p>根据zookeeper的这些特性，我们来看看如何利用这些特性来实现分布式锁：</p><ol><li><p>创建一个锁目录lock</p></li><li><p>希望获得锁的线程A就在lock目录下，创建临时顺序节点</p></li><li><p>获取锁目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁</p></li><li><p>线程B获取所有节点，判断自己不是最小节点，设置监听(watcher)比自己次小的节点（只关注比自己次小的节点是为了防止发生“羊群效应”）</p></li><li><p>线程A处理完，删除自己的节点，线程B监听到变更事件，判断自己是最小的节点，获得锁。</p></li></ol><p><img src="https://image.yuanzi222.com/blog/20170915/zookeeperLock.png" alt=""></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>在分布式系统中，共享资源互斥访问问题非常普遍，而针对访问共享资源的互斥问题，常用的解决方案就是使用分布式锁，这里只介绍了几种常用的分布式锁，分布式锁的实现方式还有有很多种，根据业务选择合适的分布式锁，下面对上述几种锁进行一下比较：</p><p>数据库锁：</p><ul><li><p>优点：直接使用数据库，使用简单。</p></li><li><p>缺点：分布式系统大多数瓶颈都在数据库，使用数据库锁会增加数据库负担。</p></li></ul><p>缓存锁：</p><ul><li><p>优点：性能高，实现起来较为方便，在允许偶发的锁失效情况，不影响系统正常使用，建议采用缓存锁。</p></li><li><p>缺点：通过锁超时机制不是十分可靠，当线程获得锁后，处理时间过长导致锁超时，就失效了锁的作用。</p></li></ul><p>zookeeper锁：</p><ul><li><p>优点：不依靠超时时间释放锁；可靠性高；系统要求高可靠性时，建议采用zookeeper锁。</p></li><li><p>缺点：性能比不上缓存锁，因为要频繁的创建节点删除节点。</p></li></ul></div><div class="reward" ontouchstart=""><div class="reward-wrap">赏<div class="reward-box"> <span class="reward-type"><img class="alipay" src="https://image.yuanzi222.com/blog/homeImages/alipay.jpg"><b>支付宝打赏</b></span> <span class="reward-type"><img class="wechat" src="https://image.yuanzi222.com/blog/homeImages/wechatpay.png"><b>微信打赏</b></span></div></div><p class="reward-tip">坚持原创技术分享,您的支持将鼓励我继续创作!</p></div><div class="post-footer"><div> 转载声明：商业转载请联系作者获得授权,非商业转载请注明出处<i class="fa fa-creative-commons"></i> <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noopener noreferrer" target="_blank">署名-非商业性使用-禁止演绎 4.0 国际</a></div><div></div></div><div class="addthis_inline_share_toolbox"><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5b63c2f14fb3c2a8" async="async"></script></div></article><div class="article-nav prev-next-wrap clearfix"> <a href="/分布式架构知识体系.html" class="next-post btn btn-default" title="分布式架构知识体系"><span class="hidden-lg">下一篇</span> <span class="hidden-xs">分布式架构知识体系</span><i class="fa fa-angle-right fa-fw"></i></a></div><div id="comments"><p>评论系统未开启，无法评论！</p></div></main><aside id="article-toc" role="navigation" class="col-md-4"><div class="widget"><h3 class="title">文章目录</h3><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#分布式一致性问题"><span class="toc-text">分布式一致性问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#分布式锁需要具备哪些条件"><span class="toc-text">分布式锁需要具备哪些条件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#分布式锁实现方式"><span class="toc-text">分布式锁实现方式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、数据库锁"><span class="toc-text">一、数据库锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-基于MySQL锁表"><span class="toc-text">1. 基于MySQL锁表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-采用乐观锁增加版本号"><span class="toc-text">2. 采用乐观锁增加版本号</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、缓存锁"><span class="toc-text">二、缓存锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-基于setnx、expire两个命令来实现"><span class="toc-text">1. 基于setnx、expire两个命令来实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-RedLock算法"><span class="toc-text">2. RedLock算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、zookeeper分布式锁"><span class="toc-text">三、zookeeper分布式锁</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#小结"><span class="toc-text">小结</span></a></li></ol></div></aside></div></div></section><footer class="main-footer"><div class="container"><div class="row"></div></div></footer><a id="back-to-top" class="icon-btn hide"><i class="fa fa-chevron-up"></i></a><div class="copyright"><div class="container"><div class="row"><div class="col-sm-12"><div class="busuanzi"> <span class="post-count">博客全站共34.4k字</span> | &nbsp; 访问量:<strong id="busuanzi_value_site_pv"><i class="fa fa-spinner fa-spin"></i></strong> &nbsp; | &nbsp; 访客数:<strong id="busuanzi_value_site_uv"><i class="fa fa-spinner fa-spin"></i></strong></div></div><div class="col-sm-12"> <span itemprop="copyrightYear">© 2016 - 2019</span> | <span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span> |<script>var now=new Date;function createtime(){var n=new Date("07/21/2016 09:26:12");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="本站已稳定运行 "+dnum+" 天 ",document.getElementById("times").innerHTML=hnum+" 小时 "+mnum+" 分 "+snum+" 秒"}setInterval("createtime()",250)</script> <span><a href="//yuanzi222.com" class="copyright-links" target="_blank" rel="nofollow">元子的博客</a>&nbsp; |</span> <span><a href="http://beian.miit.gov.cn/publish/query/indexFirst.action" class="copyright-links" target="_blank" rel="external nofollow noopener noreferrer">京ICP备19057262号-1</a>&nbsp; |</span> <span><img src="https://image.yuanzi222.com/blog/homeImages/beiAn.png"> <a target="_blank" style="color:#939393" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=11010802030582" rel="external nofollow noopener noreferrer">京公网安备 11010802030582号</a></span></div></div></div></div><script src="/assets/tagcanvas.min.js?rev=2.9"></script><script>var tagOption={textColour:"#444",outlineMethod:"block",outlineColour:"#FFDAB9",interval:30,textHeight:13,outlineRadius:3,freezeActive:!0,frontSelect:!0,initial:[.1,-.1],depth:.5,decel:.95,maxSpeed:.03,reverse:!0,fadeIn:500,wheelZoom:""};TagCanvas.Start("tag-cloud-3d","",tagOption)</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/app.js?rev=@@hash"></script></body>