<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Eureka比Zookeeper好在哪里]]></title>
    <url>%2FEureka%E6%AF%94Zookeeper%E5%A5%BD%E5%9C%A8%E5%93%AA%E9%87%8C.html</url>
    <content type="text"><![CDATA[作为服务注册中心，Eureka比Zookeeper好在哪里著名的CAP理论指出，一个分布式系统不可能同时满足C(一致性)、A(可用性)和P(分区容错性)。由于分区容错性在是分布式系统中必须要保证的，因此我们只能在A和C之间进行权衡。在此Zookeeper保证的是CP, 而Eureka则是AP。 Zookeeper保证CP当向注册中心查询服务列表时，我们可以容忍注册中心返回的是几分钟以前的注册信息，但不能接受服务直接down掉不可用。也就是说，服务注册功能对可用性的要求要高于一致性。但是zk会出现这样一种情况，当master节点因为网络故障与其他节点失去联系时，剩余节点会重新进行leader选举。问题在于，选举leader的时间太长，30 ~ 120s, 且选举期间整个zk集群都是不可用的，这就导致在选举期间注册服务瘫痪。在云部署的环境下，因网络问题使得zk集群失去master节点是较大概率会发生的事，虽然服务能够最终恢复，但是漫长的选举时间导致的注册长期不可用是不能容忍的。 Eureka保证APEureka看明白了这一点，因此在设计时就优先保证可用性。Eureka各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。而Eureka的客户端在向某个Eureka注册或时如果发现连接失败，则会自动切换至其它节点，只要有一台Eureka还在，就能保证注册服务可用(保证可用性)，只不过查到的信息可能不是最新的(不保证强一致性)。除此之外，Eureka还有一种自我保护机制，如果在15分钟内超过85%的节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了网络故障，此时会出现以下几种情况： Eureka不再从注册列表中移除因为长时间没收到心跳而应该过期的服务 Eureka仍然能够接受新服务的注册和查询请求，但是不会被同步到其它节点上(即保证当前节点依然可用) 当网络稳定时，当前实例新的注册信息会被同步到其它节点中 因此， Eureka可以很好的应对因网络故障导致部分节点失去联系的情况，而不会像zookeeper那样使整个注册服务瘫痪。 总结Eureka作为单纯的服务注册中心来说要比zookeeper更加“专业”，因为注册服务更重要的是可用性，我们可以接受短期内达不到一致性的状况。不过Eureka目前1.X版本的实现是基于servlet的Java web应用，它的极限性能肯定会受到影响。期待正在开发之中的2.X版本能够从servlet中独立出来成为单独可部署执行的服务。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BIO、NIO与AIO的区别]]></title>
    <url>%2FBIO%E3%80%81NIO%E4%B8%8EAIO%E7%9A%84%E5%8C%BA%E5%88%AB.html</url>
    <content type="text"><![CDATA[BIO（Blocking I/O）同步阻塞I/O这是最基本与简单的I/O操作方式，其根本特性是做完一件事再去做另一件事，一件事一定要等前一件事做完，这很符合程序员传统的顺序来开发思想，因此BIO模型程序开发起来较为简单，易于把握。 但是BIO如果需要同时做很多事情（例如同时读很多文件，处理很多tcp请求等），就需要系统创建很多线程来完成对应的工作，因为BIO模型下一个线程同时只能做一个工作，如果线程在执行过程中依赖于需要等待的资源，那么该线程会长期处于阻塞状态，我们知道在整个操作系统中，线程是系统执行的基本单位，在BIO模型下的线程 阻塞就会导致系统线程的切换，从而对整个系统性能造成一定的影响。当然如果我们只需要创建少量可控的线程，那么采用BIO模型也是很好的选择，但如果在需要考虑高并发的web或者tcp服务器中采用BIO模型就无法应对了，如果系统开辟成千上万的线程，那么CPU的执行时机都会浪费在线程的切换中，使得线程的执行效率大大降低。此外，关于线程这里说一句题外话，在系统开发中线程的生命周期一定要准确控制，在需要一定规模并发的情形下，尽量使用线程池来确保线程创建数目在一个合理的范围之内，切莫编写线程数量创建上限的代码。 NIO (New I/O) 同步非阻塞I/O关于NIO，国内有很多技术博客将英文翻译成No-Blocking I/O，非阻塞I/O模型 ，当然这样就与BIO形成了鲜明的特性对比。NIO本身是基于事件驱动的思想来实现的，其目的就是解决BIO的大并发问题，在BIO模型中，如果需要并发处理多个I/O请求，那就需要多线程来支持，NIO使用了多路复用器机制，以socket使用来说，多路复用器通过不断轮询各个连接的状态，只有在socket有流可读或者可写时，应用程序才需要去处理它，在线程的使用上，就不需要一个连接就必须使用一个处理线程了，而是只是有效请求时（确实需要进行I/O处理时），才会使用一个线程去处理，这样就避免了BIO模型下大量线程处于阻塞等待状态的情景。 相对于BIO的流，NIO抽象出了新的通道（Channel）作为输入输出的通道，并且提供了缓存（Buffer）的支持，在进行读操作时，需要使用Buffer分配空间，然后将数据从Channel中读入Buffer中，对于Channel的写操作，也需要现将数据写入Buffer，然后将Buffer写入Channel中。 如下是NIO方式进行文件拷贝操作的示例，见下图： 通过比较New IO的使用方式我们可以发现，新的IO操作不再面向 Stream来进行操作了，改为了通道Channel，并且使用了更加灵活的缓存区类Buffer，Buffer只是缓存区定义接口， 根据需要，我们可以选择对应类型的缓存区实现类。在java NIO编程中，我们需要理解以下3个对象Channel、Buffer和Selector。 Channel首先说一下Channel，国内大多翻译成“通道”。Channel和IO中的Stream(流)是差不多一个等级的。只不过Stream是单向的，譬如：InputStream, OutputStream。而Channel是双向的，既可以用来进行读操作，又可以用来进行写操作，NIO中的Channel的主要实现有：FileChannel、DatagramChannel、SocketChannel、ServerSocketChannel；通过看名字就可以猜出个所以然来：分别可以对应文件IO、UDP和TCP（Server和Client）。 BufferNIO中的关键Buffer实现有：ByteBuffer、CharBuffer、DoubleBuffer、 FloatBuffer、IntBuffer、 LongBuffer,、ShortBuffer，分别对应基本数据类型: byte、char、double、 float、int、 long、 short。当然NIO中还有MappedByteBuffer, HeapByteBuffer, DirectByteBuffer等这里先不具体陈述其用法细节。 说一下 DirectByteBuffer 与 HeapByteBuffer 的区别？它们 ByteBuffer 分配内存的两种方式。HeapByteBuffer 顾名思义其内存空间在 JVM 的 heap（堆）上分配，可以看做是 jdk 对于 byte[] 数组的封装；而 DirectByteBuffer 则直接利用了系统接口进行内存申请，其内存分配在c heap 中，这样就减少了内存之间的拷贝操作，如此一来，在使用 DirectByteBuffer 时，系统就可以直接从内存将数据写入到 Channel 中，而无需进行 Java 堆的内存申请，复制等操作，提高了性能。既然如此，为什么不直接使用 DirectByteBuffer，还要来个 HeapByteBuffer？原因在于， DirectByteBuffer 是通过full gc来回收内存的，DirectByteBuffer会自己检测情况而调用 system.gc()，但是如果参数中使用了 DisableExplicitGC 那么就无法回收该快内存了，-XX:+DisableExplicitGC标志自动将 System.gc() 调用转换成一个空操作，就是应用中调用 System.gc() 会变成一个空操作，那么如果设置了就需要我们手动来回收内存了，所以DirectByteBuffer使用起来相对于完全托管于 java 内存管理的Heap ByteBuffer 来说更复杂一些，如果用不好可能会引起OOM。Direct ByteBuffer 的内存大小受 -XX:MaxDirectMemorySize JVM 参数控制（默认大小64M），在 DirectByteBuffer 申请内存空间达到该设置大小后，会触发 Full GC。 SelectorSelector 是NIO相对于BIO实现多路复用的基础，Selector 运行单线程处理多个 Channel，如果你的应用打开了多个通道，但每个连接的流量都很低，使用 Selector 就会很方便。例如在一个聊天服务器中。要使用 Selector , 得向 Selector 注册 Channel，然后调用它的 select() 方法。这个方法会一直阻塞到某个注册的通道有事件就绪。一旦这个方法返回，线程就可以处理这些事件，事件的例子有如新的连接进来、数据接收等。 这里我们再来看一个NIO模型下的TCP服务器的实现，我们可以看到Selector 正是NIO模型下 TCP Server 实现IO复用的关键，请仔细理解下段代码while循环中的逻辑，见下图： AIO (Asynchronous I/O) 异步非阻塞I/OJava AIO就是Java作为对异步IO提供支持的NIO.2 ，Java NIO2 (JSR 203)定义了更多的 New I/O APIs， 提案2003提出，直到2011年才发布， 最终在JDK 7中才实现。JSR 203除了提供更多的文件系统操作API(包括可插拔的自定义的文件系统)， 还提供了对socket和文件的异步 I/O操作。 同时实现了JSR-51提案中的socket channel全部功能,包括对绑定， option配置的支持以及多播multicast的实现。 从编程模式上来看AIO相对于NIO的区别在于，NIO需要使用者线程不停的轮询IO对象，来确定是否有数据准备好可以读了，而AIO则是在数据准备好之后，才会通知数据使用者，这样使用者就不需要不停地轮询了。当然AIO的异步特性并不是Java实现的伪异步，而是使用了系统底层API的支持，在Unix系统下，采用了epoll IO模型，而windows便是使用了IOCP模型。关于Java AIO，本篇只做一个抛砖引玉的介绍，如果你在实际工作中用到了，那么可以参考Netty在高并发下使用AIO的相关技术。 总 结IO实质上与线程没有太多的关系，但是不同的IO模型改变了应用程序使用线程的方式，NIO与BIO的出现解决了很多BIO无法解决的并发问题，当然任何技术抛开适用场景都是耍流氓，复杂的技术往往是为了解决简单技术无法解决的问题而设计的，在系统开发中能用常规技术解决的问题，绝不用复杂技术，否则大大增加系统代码的维护难度，学习IT技术不是为了炫技，而是要实实在在解决问题。 AIO是发出IO请求后，由操作系统自己去获取IO权限并进行IO操作；NIO则是发出IO请求后，由线程不断尝试获取IO权限，获取到后通知应用程序自己进行IO操作。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HttpClient、HttpURLConnection、OKHttp和Volley]]></title>
    <url>%2FHttpClient%E3%80%81HttpURLConnection%E3%80%81OKHttp%E5%92%8CVolley.html</url>
    <content type="text"><![CDATA[今天突然想起有必要总结一下市面上通用的一些网络请求方式，主要通过分析其优缺点和性能，为以后选择网络请求连接方式提供支持。现在常用的网络请求方式主要有：HttpClient、HttpURLConnection、OKHttp和Volley。 一、HttpClient：HttpClient 是Apache的一个三方网络框架，网络请求做了完善的封装，api众多，用起来比较方便，开发快。实现比较稳定，bug比较少，但是正式由于其api众多，是我们很难再不破坏兼容性的情况下对其进行扩展。所以，Android团队对提升和优化httpclient积极性并不高。android5.0被废弃，6.0逐渐删除。 二、HttpURLConnectionHttpURLConnection是一个多用途、轻量级的http客户端。它对网络请求的封装没有HttpClient彻底，api比较简单，用起来没有那么方便。但是正是由于此，使得我们能更容易的扩展和优化的HttpURLConnection。不过，再android2.2之前一直存在着一些令人烦的bug，比如一个人可读的inputstream调用它的close方法的时候，会使得连接池实效，通常的做法就是禁用连接池。因此，在android2.2之前建议使用稳定的HttpClient，android2.2之后使用更容易扩展和优化的HttpURLConnection。 三、okhttp 支持Android 2.3及其以上版本； 支持Java JDK 1.7以上版本； okhttp是专注于提升网络连接效率的http客户端。 它能实现同一ip和端口的请求重用一个socket，这种方式能大大降低网络连接的时间，和每次请求都建立socket，再断开socket的方式相比，降低了服务器服务器的压力。 okhttp 对http和https都有良好的支持。 okhttp 不用担心android版本变换的困扰。 成熟的网络请求解决方案，比HttpURLConnection更好用。 缺点，okhttp请求网络切换回来是在线程里面的，不是在主线程，不能直接刷新UI，需要我们手动处理。封装比较麻烦。 四、VolleyVolley是google在2013 io大会上推出的网络通信框架，特别适合处理数据量小，通信频繁的网络操作。优点是内部封装了异步线程，可直接在主线程请求网络，并处理返回的结果。同时可以取消请求，容易扩展。缺点是：面对大数据量的请求，比如下载表现糟糕，不支持https。Volley的底层在针对android2.3以下系统使用httpclicent，在android2.3以上采用HttpUrlConnection请求网络。 本公司的选择：公司使用Volley框架来处理网络请求，但是，当数据量需求越来大的时候，Volley在面对大数据量的网络请求的表现并不好，加上公司大量采用https协议。于是，公司网络请求采用了Volley＋okhttp。正如我们采用这种方式的优势有： okhttp 不用担心android版本变换的困扰。 okhttp 对大数据量的网络请求支持非常好。 okhttp 同时支持http和https okhttp 重用socket连接，网络请求效率非常高。 Volley框架在异步请求的封装非常好，对子线程网络请求，主线程更新UI支持非常好。能像Image-Loader一样轻松加载网络图片。总之，网络请求底层采用okhttp，异步回调使用Volley框架。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[后端Long类型过大时返回前端js会丢失精度问题的解决办法]]></title>
    <url>%2F%E5%90%8E%E7%AB%AFLong%E7%B1%BB%E5%9E%8B%E8%BF%87%E5%A4%A7%E6%97%B6%E8%BF%94%E5%9B%9E%E5%89%8D%E7%AB%AFjs%E4%BC%9A%E4%B8%A2%E5%A4%B1%E7%B2%BE%E5%BA%A6%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95.html</url>
    <content type="text"><![CDATA[问题描述后端返回给前端的id是18341382392905728，但前端js显示的是18341382392905730(错误的id)。 根本原因我们后端用的雪花算法来生成id，是17位的而js的number类型有个最大值（安全值）。即2的53次方，为9007199254740992。如果超过这个值，那么js会出现不精确的问题。这个值为16位。 解决方法将后端返回参数为Long类型的都转为字符串再返回给前端。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux SSH各配置项详解]]></title>
    <url>%2FLinux%20SSH%E5%90%84%E9%85%8D%E7%BD%AE%E9%A1%B9%E8%AF%A6%E8%A7%A3.html</url>
    <content type="text"><![CDATA[关于ssh设置的相关总结（ssh最大连接数、ssh连接时长、安全性配置等)，以redhat6.3为例: ssh配置文件在：/etc/ssh/sshd_config可以打开查看相应配置，默认情况下只开放了几个选项，其余全部#屏蔽掉了。 英文手册参考:http://www.openbsd.org/cgi-bin/man.cgi?query=sshd_config 国内有人已经翻译了：（直接贴过来了） sshd_config中文手册:SSHD_CONFIG(5) OpenBSD Programmer’s Manual SSHD_CONFIG(5) 名称sshd_config - OpenSSH SSH 服务器守护进程配置文件 描述sshd(8) 默认从 /etc/ssh/sshd_config 文件(或通过 -f 命令行选项指定的文件)读取配置信息。配置文件是由”指令 值”对组成的，每行一个。空行和以’#’开头的行都将被忽略。如果值中含有空白符或者其他特殊符号，那么可以通过在两边加上双引号(“)进行界定。[注意]值是大小写敏感的，但指令是大小写无关的。 当前所有可以使用的配置指令如下:AcceptEnv指定客户端发送的哪些环境变量将会被传递到会话环境中。[注意]只有SSH-2协议支持环境变量的传递。细节可以参考 ssh_config(5) 中的 SendEnv 配置指令。指令的值是空格分隔的变量名列表(其中可以使用’*’和’?’作为通配符)。也可以使用多个 AcceptEnv 达到同样的目的。需要注意的是，有些环境变量可能会被用于绕过禁止用户使用的环境变量。由于这个原因，该指令应当小心使用。默认是不传递任何环境变量。 AddressFamily指定 sshd(8) 应当使用哪种地址族。取值范围是：”any”(默认)、”inet”(仅IPv4)、”inet6”(仅IPv6)。 AllowGroups这个指令后面跟着一串用空格分隔的组名列表(其中可以使用”*”和”?”通配符)。默认允许所有组登录。如果使用了这个指令，那么将仅允许这些组中的成员登录，而拒绝其它所有组。这里的”组”是指”主组”(primary group)，也就是/etc/passwd文件中指定的组。这里只允许使用组的名字而不允许使用GID。相关的 allow/deny 指令按照下列顺序处理：DenyUsers, AllowUsers, DenyGroups, AllowGroups AllowTcpForwarding是否允许TCP转发，默认值为”yes”。禁止TCP转发并不能增强安全性，除非禁止了用户对shell的访问，因为用户可以安装他们自己的转发器。 AllowUsers这个指令后面跟着一串用空格分隔的用户名列表(其中可以使用”*”和”?”通配符)。默认允许所有用户登录。如果使用了这个指令，那么将仅允许这些用户登录，而拒绝其它所有用户。如果指定了 USER@HOST 模式的用户，那么 USER 和 HOST 将同时被检查。这里只允许使用用户的名字而不允许使用UID。相关的 allow/deny 指令按照下列顺序处理：DenyUsers, AllowUsers, DenyGroups, AllowGroups AuthorizedKeysFile存放该用户可以用来登录的 RSA/DSA 公钥。该指令中可以使用下列根据连接时的实际情况进行展开的符号：%% 表示’%’、%h 表示用户的主目录、%u 表示该用户的用户名。经过扩展之后的值必须要么是绝对路径，要么是相对于用户主目录的相对路径。默认值是”.ssh/authorized_keys”。 Banner将这个指令指定的文件中的内容在用户进行认证前显示给远程用户。这个特性仅能用于SSH-2，默认什么内容也不显示。”none”表示禁用这个特性。 ChallengeResponseAuthentication是否允许质疑-应答(challenge-response)认证。默认值是”yes”。所有 login.conf(5) 中允许的认证方式都被支持。 Ciphers指定SSH-2允许使用的加密算法。多个算法之间使用逗号分隔。可以使用的算法如下：“aes128-cbc”, “aes192-cbc”, “aes256-cbc”, “aes128-ctr”, “aes192-ctr”, “aes256-ctr”,“3des-cbc”, “arcfour128”, “arcfour256”, “arcfour”, “blowfish-cbc”, “cast128-cbc”默认值是可以使用上述所有算法。 ClientAliveCountMaxsshd(8) 在未收到任何客户端回应前最多允许发送多少个”alive”消息。默认值是 3 。到达这个上限后，sshd(8) 将强制断开连接、关闭会话。需要注意的是，”alive”消息与 TCPKeepAlive 有很大差异。“alive”消息是通过加密连接发送的，因此不会被欺骗；而 TCPKeepAlive 却是可以被欺骗的。如果 ClientAliveInterval 被设为 15 并且将 ClientAliveCountMax 保持为默认值，那么无应答的客户端大约会在45秒后被强制断开。这个指令仅可以用于SSH-2协议。 ClientAliveInterval设置一个以秒记的时长，如果超过这么长时间没有收到客户端的任何数据，sshd(8) 将通过安全通道向客户端发送一个”alive”消息，并等候应答。默认值 0 表示不发送”alive”消息。这个选项仅对SSH-2有效。 Compression是否对通信数据进行加密，还是延迟到认证成功之后再对通信数据加密。可用值：”yes”, “delayed”(默认), “no”。 DenyGroups这个指令后面跟着一串用空格分隔的组名列表(其中可以使用”*”和”?”通配符)。默认允许所有组登录。如果使用了这个指令，那么这些组中的成员将被拒绝登录。这里的”组”是指”主组”(primary group)，也就是/etc/passwd文件中指定的组。这里只允许使用组的名字而不允许使用GID。相关的 allow/deny 指令按照下列顺序处理：DenyUsers, AllowUsers, DenyGroups, AllowGroups DenyUsers这个指令后面跟着一串用空格分隔的用户名列表(其中可以使用”*”和”?”通配符)。默认允许所有用户登录。如果使用了这个指令，那么这些用户将被拒绝登录。如果指定了 USER@HOST 模式的用户，那么 USER 和 HOST 将同时被检查。这里只允许使用用户的名字而不允许使用UID。相关的 allow/deny 指令按照下列顺序处理：DenyUsers, AllowUsers, DenyGroups, AllowGroups ForceCommand强制执行这里指定的命令而忽略客户端提供的任何命令。这个命令将使用用户的登录shell执行(shell -c)。这可以应用于 shell 、命令、子系统的完成，通常用于 Match 块中。这个命令最初是在客户端通过 SSH_ORIGINAL_COMMAND 环境变量来支持的。 GatewayPorts是否允许远程主机连接本地的转发端口。默认值是”no”。sshd(8) 默认将远程端口转发绑定到loopback地址。这样将阻止其它远程主机连接到转发端口。GatewayPorts 指令可以让 sshd 将远程端口转发绑定到非loopback地址，这样就可以允许远程主机连接了。“no”表示仅允许本地连接，”yes”表示强制将远程端口转发绑定到统配地址(wildcard address)，“clientspecified”表示允许客户端选择将远程端口转发绑定到哪个地址。 GSSAPIAuthentication是否允许使用基于 GSSAPI 的用户认证。默认值为”no”。仅用于SSH-2。 GSSAPICleanupCredentials是否在用户退出登录后自动销毁用户凭证缓存。默认值是”yes”。仅用于SSH-2。 HostbasedAuthentication这个指令与 RhostsRSAAuthentication 类似，但是仅可以用于SSH-2。推荐使用默认值”no”。推荐使用默认值”no”禁止这种不安全的认证方式。 HostbasedUsesNameFromPacketOnly在开启 HostbasedAuthentication 的情况下，指定服务器在使用 ~/.shosts ~/.rhosts /etc/hosts.equiv 进行远程主机名匹配时，是否进行反向域名查询。“yes”表示 sshd(8) 信任客户端提供的主机名而不进行反向查询。默认值是”no”。 HostKey主机私钥文件的位置。如果权限不对，sshd(8) 可能会拒绝启动。SSH-1默认是 /etc/ssh/ssh_host_key 。SSH-2默认是 /etc/ssh/ssh_host_rsa_key 和 /etc/ssh/ssh_host_dsa_key 。一台主机可以拥有多个不同的私钥。”rsa1”仅用于SSH-1，”dsa”和”rsa”仅用于SSH-2。 IgnoreRhosts是否在 RhostsRSAAuthentication 或 HostbasedAuthentication 过程中忽略 .rhosts 和 .shosts 文件。不过 /etc/hosts.equiv 和 /etc/shosts.equiv 仍将被使用。推荐设为默认值”yes”。 IgnoreUserKnownHosts是否在 RhostsRSAAuthentication 或 HostbasedAuthentication 过程中忽略用户的 ~/.ssh/known_hosts 文件。默认值是”no”。为了提高安全性，可以设为”yes”。 KerberosAuthentication是否要求用户为 PasswordAuthentication 提供的密码必须通过 Kerberos KDC 认证，也就是是否使用Kerberos认证。要使用Kerberos认证，服务器需要一个可以校验 KDC identity 的 Kerberos servtab 。默认值是”no”。 KerberosGetAFSToken如果使用了 AFS 并且该用户有一个 Kerberos 5 TGT，那么开启该指令后，将会在访问用户的家目录前尝试获取一个 AFS token 。默认为”no”。 KerberosOrLocalPasswd如果 Kerberos 密码认证失败，那么该密码还将要通过其它的认证机制(比如 /etc/passwd)。默认值为”yes”。 KerberosTicketCleanup是否在用户退出登录后自动销毁用户的 ticket 。默认值是”yes”。 KeyRegenerationInterval在SSH-1协议下，短命的服务器密钥将以此指令设置的时间为周期(秒)，不断重新生成。这个机制可以尽量减小密钥丢失或者黑客攻击造成的损失。设为 0 表示永不重新生成，默认为 3600(秒)。 ListenAddress指定 sshd(8) 监听的网络地址，默认监听所有地址。可以使用下面的格式： ListenAddresshost|IPv4_addr|IPv6_addrListenAddress host|IPv4_addr:portListenAddress [host|IPv6_addr]:port 如果未指定 port ，那么将使用 Port 指令的值。可以使用多个 ListenAddress 指令监听多个地址。 LoginGraceTime限制用户必须在指定的时限内认证成功，0 表示无限制。默认值是 120 秒。 LogLevel指定 sshd(8) 的日志等级(详细程度)。可用值如下：QUIET, FATAL, ERROR, INFO(默认), VERBOSE, DEBUG, DEBUG1, DEBUG2, DEBUG3DEBUG 与 DEBUG1 等价；DEBUG2 和 DEBUG3 则分别指定了更详细、更罗嗦的日志输出。比 DEBUG 更详细的日志可能会泄漏用户的敏感信息，因此反对使用。 MACs指定允许在SSH-2中使用哪些消息摘要算法来进行数据校验。可以使用逗号分隔的列表来指定允许使用多个算法。默认值(包含所有可以使用的算法)是：hmac-md5,hmac-sha1,umac-64@openssh.com,hmac-ripemd160,hmac-sha1-96,hmac-md5-96 Match引入一个条件块。块的结尾标志是另一个 Match 指令或者文件结尾。如果 Match 行上指定的条件都满足，那么随后的指令将覆盖全局配置中的指令。Match 的值是一个或多个”条件-模式”对。可用的”条件”是：User, Group, Host, Address 。只有下列指令可以在 Match 块中使用：AllowTcpForwarding, Banner,ForceCommand, GatewayPorts, GSSApiAuthentication,KbdInteractiveAuthentication, KerberosAuthentication,PasswordAuthentication, PermitOpen, PermitRootLogin,RhostsRSAAuthentication, RSAAuthentication, X11DisplayOffset,X11Forwarding, X11UseLocalHost MaxAuthTries指定每个连接最大允许的认证次数。默认值是 6 。如果失败认证的次数超过这个数值的一半，连接将被强制断开，且会生成额外的失败日志消息。 MaxStartups最大允许保持多少个未认证的连接。默认值是 10 。到达限制后，将不再接受新连接，除非先前的连接认证成功或超出 LoginGraceTime 的限制。 PasswordAuthentication是否允许使用基于密码的认证。默认为”yes”。 PermitEmptyPasswords是否允许密码为空的用户远程登录。默认为”no”。 PermitOpen指定TCP端口转发允许的目的地，可以使用空格分隔多个转发目标。默认允许所有转发请求。合法的指令格式如下：PermitOpen host:portPermitOpen IPv4_addr:portPermitOpen [IPv6_addr]:port“any”可以用于移除所有限制并允许一切转发请求。 PermitRootLogin是否允许 root 登录。可用值如下：“yes”(默认) 表示允许。”no”表示禁止。“without-password”表示禁止使用密码认证登录。“forced-commands-only”表示只有在指定了 command 选项的情况下才允许使用公钥认证登录。同时其它认证方法全部被禁止。这个值常用于做远程备份之类的事情。 PermitTunnel是否允许 tun(4) 设备转发。可用值如下：“yes”, “point-to-point”(layer 3), “ethernet”(layer 2), “no”(默认)。“yes”同时蕴含着”point-to-point”和”ethernet”。 PermitUserEnvironment指定是否允许 sshd(8) 处理 ~/.ssh/environment 以及 ~/.ssh/authorized_keys 中的 environment= 选项。默认值是”no”。如果设为”yes”可能会导致用户有机会使用某些机制(比如 LD_PRELOAD)绕过访问控制，造成安全漏洞。 PidFile指定在哪个文件中存放SSH守护进程的进程号，默认为 /var/run/sshd.pid 文件。 Port指定 sshd(8) 守护进程监听的端口号，默认为 22 。可以使用多条指令监听多个端口。默认将在本机的所有网络接口上监听，但是可以通过 ListenAddress 指定只在某个特定的接口上监听。 PrintLastLog指定 sshd(8) 是否在每一次交互式登录时打印最后一位用户的登录时间。默认值是”yes”。 PrintMotd指定 sshd(8) 是否在每一次交互式登录时打印 /etc/motd 文件的内容。默认值是”yes”。 Protocol指定 sshd(8) 支持的SSH协议的版本号。‘1’和’2’表示仅仅支持SSH-1和SSH-2协议。”2,1”表示同时支持SSH-1和SSH-2协议。 PubkeyAuthentication是否允许公钥认证。仅可以用于SSH-2。默认值为”yes”。 RhostsRSAAuthentication是否使用强可信主机认证(通过检查远程主机名和关联的用户名进行认证)。仅用于SSH-1。这是通过在RSA认证成功后再检查 ~/.rhosts 或 /etc/hosts.equiv 进行认证的。出于安全考虑，建议使用默认值”no”。 RSAAuthentication是否允许使用纯 RSA 公钥认证。仅用于SSH-1。默认值是”yes”。 ServerKeyBits指定临时服务器密钥的长度。仅用于SSH-1。默认值是 768(位)。最小值是 512 。 StrictModes指定是否要求 sshd(8) 在接受连接请求前对用户主目录和相关的配置文件进行宿主和权限检查。强烈建议使用默认值”yes”来预防可能出现的低级错误。 Subsystem配置一个外部子系统(例如，一个文件传输守护进程)。仅用于SSH-2协议。值是一个子系统的名字和对应的命令行(含选项和参数)。比如”sft /bin/sftp-server”。 SyslogFacility指定 sshd(8) 将日志消息通过哪个日志子系统(facility)发送。有效值是：DAEMON, USER, AUTH(默认), LOCAL0, LOCAL1, LOCAL2, LOCAL3, LOCAL4, LOCAL5, LOCAL6, LOCAL7 TCPKeepAlive指定系统是否向客户端发送 TCP keepalive 消息。默认值是”yes”。这种消息可以检测到死连接、连接不当关闭、客户端崩溃等异常。可以设为”no”关闭这个特性。 UseDNS指定 sshd(8) 是否应该对远程主机名进行反向解析，以检查此主机名是否与其IP地址真实对应。默认值为”yes”。 UseLogin是否在交互式会话的登录过程中使用 login(1) 。默认值是”no”。如果开启此指令，那么 X11Forwarding 将会被禁止，因为 login(1) 不知道如何处理 xauth(1) cookies 。需要注意的是，login(1) 是禁止用于远程执行命令的。如果指定了 UsePrivilegeSeparation ，那么它将在认证完成后被禁用。 UsePrivilegeSeparation是否让 sshd(8) 通过创建非特权子进程处理接入请求的方法来进行权限分离。默认值是”yes”。认证成功后，将以该认证用户的身份创建另一个子进程。这样做的目的是为了防止通过有缺陷的子进程提升权限，从而使系统更加安全。 X11DisplayOffset指定 sshd(8) X11 转发的第一个可用的显示区(display)数字。默认值是 10 。这个可以用于防止 sshd 占用了真实的 X11 服务器显示区，从而发生混淆。 X11Forwarding是否允许进行 X11 转发。默认值是”no”，设为”yes”表示允许。如果允许X11转发并且sshd(8)代理的显示区被配置为在含有通配符的地址(X11UseLocalhost)上监听。那么将可能有额外的信息被泄漏。由于使用X11转发的可能带来的风险，此指令默认值为”no”。需要注意的是，禁止X11转发并不能禁止用户转发X11通信，因为用户可以安装他们自己的转发器。如果启用了 UseLogin ，那么X11转发将被自动禁止。 X11UseLocalhostsshd(8) 是否应当将X11转发服务器绑定到本地loopback地址。默认值是”yes”。sshd 默认将转发服务器绑定到本地loopback地址并将 DISPLAY 环境变量的主机名部分设为”localhost”。这可以防止远程主机连接到 proxy display 。不过某些老旧的X11客户端不能在此配置下正常工作。为了兼容这些老旧的X11客户端，你可以设为”no”。 XAuthLocation指定 xauth(1) 程序的绝对路径。默认值是 /usr/X11R6/bin/xauth 时间格式在 sshd(8) 命令行参数和配置文件中使用的时间值可以通过下面的格式指定：time[qualifier] 。其中的 time 是一个正整数，而 qualifier 可以是下列单位之一：&lt;无&gt; 秒s | S 秒m | M 分钟h | H 小时d | D 天w | W 星期 可以通过指定多个数值来累加时间，比如：1h30m 1 小时 30 分钟 (90 分钟) 文件/etc/ssh/sshd_configsshd(8) 的主配置文件。这个文件的宿主应当是root，权限最大可以是”644”。 参见sshd(8) 作者OpenSSH is a derivative of the original and free ssh 1.2.12 release byTatu Ylonen. Aaron Campbell, Bob Beck, Markus Friedl, Niels Provos, Theode Raadt and Dug Song removed many bugs, re-added newer features and cre-ated OpenSSH. Markus Friedl contributed the support for SSH protocolversions 1.5 and 2.0. Niels Provos and Markus Friedl contributed supportfor privilege separation. OpenBSD 4.2 January 1, 2008 9Vbird网络篇里的说明：1. 关于 SSH Server 的整体设定,包含使用的 port 啦,以及使用的密码演算方式先留意一下,在预设的文件内,只要是被批注的设定值(#),即为『默认值!』 Port 22SSH 预设使用 22 这个 port,也可以使用多个 port,即重复使用 port 这个设定项目! # 例如想要开放 sshd 在 22 与 443 ,则多加一行内容为: 1# Port 443 这样就好了!不过,不建议修改 port number rotocol 1,2选择的 SSH 协议版本,可以是 1 也可以是 2 ,如果要同时支持两者,就必须要使用 2,1 这个分隔了(Protocol 1,2)! # 目前我们会建议您,直接使用 Protocol 2 即可! ListenAddress 0.0.0.0监听的主机适配卡!举个例子来说,如果您有两个 IP,分别是 192.168.0.100 及 192.168.2.20 ,那么只想要开放 192.168.0.100 时,就可以写如同下面的样式: 1ListenAddress 192.168.0.100 只监听来自 192.168.0.100 这个 IP 的 SSH 联机。如果不使用设定的话,则预设所有接口均接受 SSH PidFile /var/run/sshd.pid可以放置 SSHD 这个 PID 的文件!左列为默认值 LoginGraceTime 2m当使用者连上 SSH server 之后,会出现输入密码的画面,在该画面中,在多久时间内没有成功连上 SSH server ,就断线!若无单位则预设时间为秒! Compression yes是否可以使用压缩指令?当然可以 2. 说明主机的 Private Key 放置的档案,预设使用下面的档案即可!HostKey /etc/ssh/ssh_host_key # SSH version 1 使用的私钥HostKey /etc/ssh/ssh_host_rsa_key # SSH version 2 使用的 RSA 私钥HostKey /etc/ssh/ssh_host_dsa_key # SSH version 2 使用的 DSA 私钥还记得我们在主机的 SSH 联机流程里面谈到的,这里就是 Host Key 2.1 关于 version 1 的一些设定!KeyRegenerationInterval 1h由前面联机的说明可以知道, version 1 会使用 server 的 Public Key ,那么如果这个 Public Key 被偷的话,岂不完蛋?所以需要每隔一段时间来重新建立一次!这里的时间为秒!不过我们通常都仅使用 version 2 ,所以这个设定可以被忽略喔! ServerKeyBits 768没错!这个就是 Server key 的长度!用默认值即可。 3. 关于登录文件的讯息数据放置与 daemon 的名称!SyslogFacility AUTHPRIV当有人使用 SSH 登入系统的时候,SSH 会记录信息,这个信息要记录在什么 daemon name底下?预设是以 AUTH 来设定的,即是 /var/log/secure 里面!其它可用的 daemon name 为:DAEMON,USER,AUTH,LOCAL0,LOCAL1,LOCAL2,LOCAL3,LOCAL4,LOCAL5, LogLevel INFO登录记录的等级!注意登机信息可参照vbird基础篇详解。 4. 安全设定项目!极重要!4.1 登入设定部分PermitRootLogin no是否允许 root 登入!预设是允许的,但是建议设定成 no! UserLogin no在 SSH 底下本来就不接受 login 这个程序的登入! StrictModes yes当使用者的 host key 改变之后,Server 就不接受联机,可以抵挡部分的木马程序! RSAAuthentication yes是否使用纯的 RSA 认证!?仅针对 version 1 ! PubkeyAuthentication yes是否允许 Public Key ?当然允许啦!仅针对 version 2 AuthorizedKeysFile .ssh/authorized_keys上面这个在设定若要使用不需要密码登入的账号时,那么那个账号的存放密码所在文件名! 这个设定值很重要喔!文件名记一下! 4.2 认证部分RhostsAuthentication no本机系统不使用 .rhosts,因为仅使用 .rhosts 太不安全了,所以这里一定要设定为 no IgnoreRhosts yes是否取消使用 ~/.ssh/.rhosts 来做为认证!当然是! RhostsRSAAuthentication no这个选项是专门给 version 1 用的,使用 rhosts 文件在 /etc/hosts.equiv 配合 RSA 演算方式来进行认证!不要使用啊! HostbasedAuthentication no这个项目与上面的项目类似,不过是给 version 2 使用的! IgnoreUserKnownHosts no是否忽略家目录内的 ~/.ssh/known_hosts 这个文件所记录的主机内容?当然不要忽略,所以这里就是 no 啦! PasswordAuthentication yes密码验证当然是需要的!所以这里写 yes 啰! PermitEmptyPasswords no若上面那一项如果设定为 yes 的话,这一项就最好设定为 no 这个项目在是否允许以空的密码登入!当然不许! ChallengeResponseAuthentication no允许任何的密码认证!所以,任何 login.conf 规定的认证方式,均可适用!但目前我们比较喜欢使用 PAM 模块帮忙管理认证,因此这个选项可以设定为 no 喔! UsePAM yes利用 PAM 管理使用者认证有很多好处,可以记录与管理。所以这里我们建议您使用 UsePAM 且 ChallengeResponseAuthentication 设定为 no 4.3 与 Kerberos有关的参数设定!因为我们没有 Kerberos 主机,所以底下不用设定! #KerberosAuthentication no #KerberosOrLocalPasswd yes #KerberosTicketCleanup yes #KerberosTgtPassing no# 4.4 底下是有关在 X-Window 底下使用的相关设定! X11Forwarding yes #X11DisplayOffset 10 #X11UseLocalhost yes 4.5 登入后的项目:PrintMotd no登入后是否显示出一些信息呢?例如上次登入的时间、地点等等,预设是 yes,亦即是打印出 /etc/motd 这个档案的内容。但是,如果为了安全,可以考虑改为 no ! PrintLastLog yes显示上次登入的信息!可以啊!预设也是 yes ! KeepAlive yes一般而言,如果设定这项目的话,那么 SSH Server 会传送 KeepAlive 的讯息给Client 端,以确保两者的联机正常!在这个情况下,任何一端死掉后,SSH 可以立刻知道!而不会有僵尸程序的发生! UsePrivilegeSeparation yes使用者的权限设定项目!就设定为 yes 吧! MaxStartups 10同时允许几个尚未登入的联机画面?当我们连上 SSH ,但是尚未输入密码时,这个时候就是我们所谓的联机画面啦!在这个联机画面中,为了保护主机,所以需要设定最大值,预设最多十个联机画面,而已经建立联机的不计算在这十个当中 4.6 关于使用者抵挡的设定项目:DenyUsers *设定受抵挡的使用者名称,如果是全部的使用者,那就是全部挡吧!若是部分使用者,可以将该账号填入!例如下列! 1DenyUsers test DenyGroups test与 DenyUsers 相同!仅抵挡几个群组而已! 5. sshd安全配置(防止攻击) 改端口号 1Port 10232 指定每个连接最大允许的认证次数 1MaxAuthTries 6]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写给25岁的你和我——90后自白]]></title>
    <url>%2F%E5%86%99%E7%BB%9925%E5%B2%81%E7%9A%84%E4%BD%A0%E5%92%8C%E6%88%91%E2%80%94%E2%80%9490%E5%90%8E%E8%87%AA%E7%99%BD.html</url>
    <content type="text"><![CDATA[20多岁的年轻人， 有没有人想想， 自己30多岁会是什么样子？ 再回头看，过去的几年自己是什么样子？ 我敢想，那你呢？ 「今天我们的聊聊twentysomething，也就是20多岁的年轻人应该明白什么」 1 学会用习惯和知识武装自己 我们的一生都是由许许多多的小习惯构成的，从小时候习惯咬指甲，吃饭时候习惯先洗手后就餐，到长大成人习惯将四季衣服分类叠好放置，习惯见到陌生人给一个善意且真诚的微笑。好的习惯决定了人的一生，从饮食作息习惯到阅读学习习惯，这些习惯在潜移默化中造就了我们自己（The habits you formed shaped youself.）。在这里我就直接将几个个人认为且坚持践行的好习惯（原因就不在此赘述）： 吃饭七分饱。 坚持有氧运动，比如慢跑，骑单车，后期我自己也打算去学学游泳。 学会记录（要有本子和笔，动手写字，电子笔记是辅助），记录生活中一切可记录的东西，时间?开销，金钱开支。 坚持读文章（中文或者英文） 定期去接近大自然，将心放空。 定期看一部电影（包括但不限于美剧，英剧，想想你自己看过哪些国家的电影呢？） 定期写字，写手稿??。 开始脱离手机的控制（我指的是那些被手机奴役的人）。 定期清理个人物品，整理房间（也就是断舍离）。 多喝白开水（或者说只喝），多吃深色蔬菜（不要一味追求口感）。 强制储蓄，记账 学会列清单。 不因自己的存在而影响他人。 下面说说知识，我们从小就被灌输以 “知识就是力量” 这样的结论，当长大成人依然能够用知识武装自己的人便不多了，很多人无法分清上学和学习是两件事情。一说“你看书呢？” “你是学生吧。” 似乎只有学生?才天经地义应该读书，工作上班了就该忙工作。我个人接触理财投资，顶尖投资人都是海量阅读的践行者，注意海量阅读是结果，不是目标。也即是说投资需要具备综合学科的知识，比如著名投资家查理芒格不仅研究投资理论，而且广泛且深入学习包括微观经济学、心理学、法律、数学、生物学和工程学等多领域知识，将领域洞见应用到投资领域。就我们个人来说，其实掌握最少必要知识MRK（Minimum required knowledge）即可，比如数学中的统计概率思想，基本英文阅读能力，金融学经济学常识或者说类似的通识知识，再如心理学，逻辑学。一个受过良好心理学和逻辑训练的人情商和思维能力自然更高。 因此如果将知识水平按百分数来计算，假设一个人英文水平30%，数学知识30%，编程能力50%，金融知识35%，逻辑思维25%，写作技能60%，演讲技能40%，这样技能的叠加，综合下来是非常有竞争力的。投资人，CEO基本上都是多技能综合体。俗话说：“千金在手，不如一技傍身” 就是这个道理。补充一句：学习如何学习以及学习如何读书也是一门学问。 2 开始记录，感知时间 历史上，现实中伟大的人物，或者说厉害的牛人都是对时间极为敏感或者惜时的人。至少在我心中，比如稻盛和夫、本杰明富兰克林、柳比歇夫都是对时间对掌控能力较强的人。其实掌控时间这个说法不太合适，我们应当和时间做朋友，而不是控制它。很多人知道记账，但是鲜有人知道去记录时间的开支，它有什么好处呢？其一让你知道自己做什么事情要需要多久，其二增加自己对时间对敏感度，最后还可以用来反思哪些时间不该花，哪些事情上应该多花些时间。我们都是在时间这个维度下生存的，当你拥有这个维度去做事的时候就会发现时间的美丽，我们逃离不要宇宙时间的如来神掌。任何事情被给予时间这个因素都会发生量变到质变的过程，比如皮肤的衰老，投资的回报（复利效应），一座历史古城被时间所洗礼后的模样。 因此从今天起，找一个笔记本，开始记录自己的时间开支，否则你会成为一个失控的人，一旦时间失控，后面的话我就不讲了。 3 做一个学生，一年拜一师 这一点其实也是我自己的一个可以说是一个习惯也好原则也好。那就是做一个合格的学生，什么是合格的学生？在老师靠谱的情况下，不因老师个人因素而影响自己接受知识。我自己差不多一年会 “拜” 一个老师，其实不是真的去拜，而是每天增加一个可以向其学习的人，一个榜样，一个行业领袖，一个社会名流，往俗了讲就是厉害牛X的人，比如查理芒格、李开复、李笑来、王石、徐小平、王强、俞敏洪、吴晓波、吴军（排序没有先后），个人认为总要有一个人生导师存在你的灵魂深处，必要时可以向他 “求助”——自问自答，反思自我。我常常看这些人的微博，看他们的生活，他们的关注点，毕竟自己见识有限，有这些老师在自己心中感觉非常踏实，而且自己也是有机会见到这些老师。即便不是人生导师，对于行业中的意见领袖也应当给予关注，时刻关注行业动态。你自己可以对自己骄傲的说一声： “我是XXX的学生。” 4 活着要有自驱力，做自燃人 说到自驱力，其实类似稻盛和夫讲：「成为自燃型的人，带着爱去工作！」 物质有“可燃型”、“不燃型”和“自燃型”三种。同样，人也可以分为三种： 第一种是点火就着的“可燃型”的人； 第二种是点火也烧不起来的“不燃型”的人； 第三种是自己就能熊熊燃烧的“自燃型”的人。 想要成就某项事业，就必须成为“自燃型”的人，在热爱自己工作的同时，必须持有明确的目标。 在一个学校或者公司中，或者说生活中，要做一个有自驱力的人，就像四驱赛车???一样，不是靠外在压力要求来做事，做一个积极主动（proactive）的人，主动性人格。有自驱力且积极主动会让你发现新的东西，让领导同事喜欢，和爱人关系也会变得融洽。 5 关注眼睛看不到的东西 永远要清楚我们的认知有限需要不断升级，想想生活中哪些是看得见的东西，哪些是看不见的？（一件事情背后深层的原因是什么？你对金钱对认识如何？宏观经济呢？社会现象呢？）通常来讲，人对看不见或者未能预见的东西认识不足，没有概念。比如时间，比如微信钱包和支付宝余额中的躺着的数字，比如人的情商，但是看到的东西呢？下面是豆瓣网友「沉默是Daisy」写的对《精进》这本书的评论： 作者针对事件值不值得做，提出了两个维度的评价标准： 「收益值」是指该事件带来的收益大小（认知、情感、物质、身体方面的收益皆可计入）； 「半衰期」是指该收益随时间衰减的速度，半衰期长的事件，影响会持续地较久较长。 在这两个维度的交叉情况下，日常事情都可分为四个类： ? 高收益值、长半衰期事件：如找到真爱 ? 高收益值、短半衰期事件：如淘宝一件时髦的衣服 ? 低收益值、长半衰期事件：如阅读一本经典小说 ? 低收益值、短半衰期事件：如漫无目的地刷朋友圈 仔细一想，平时做得最多的，便是「高收益值、短半衰期事件」，其次是「低收益值、短半衰期事件」，而另两类长半衰期事件却做得很少。作者建议尽量少做「短半衰期」的事情，原因是短半衰期事件大多无关紧要，进行过程中纵然爽快，但完成之后眨眼就忘了；反观长半衰期事件，比如阅读经典，效益可以累计和叠加，即使收益低，长此以往也能慢慢积累，有助于成长。 半衰期这个理念涉及化学，在这里用来判断事情，让人耳目一新。从一个全新的角度，看问题马上不一样了，仿佛从原来二维的角度拓宽到三维，个中区别马上看的清楚。人生的目的如果是不断精进，那多做「长半衰期」的事情，才是帮助自己提高的不二之道。 有句话叫：「日拱一卒无有尽,功不唐捐终入海 」，看不到的事情可能是有价值的事情，看不到的事情也可能是我们尚未能够理解的事情，这个世界真实的样子是什么？当我们多读历史，不断更新自己的知识和经验的时候才更容易看清世界本来的样子。 6 直面恐惧，别被自己吓倒 最近看《十三邀》第三季，许知远对话王石，其中王石说到： 孤独感呢，第一点实际上就是你对死亡的一个恐惧和规避。第二点，那就是原来是很多人对你都不了解。但更多的来讲，是你对这个社会的不了解。而这种不了解，造成一种孤独感。如果你愿意去拥抱这个世界，这个世界是接受你的。帕斯卡说：假设你相信上帝存在,并按照基督教的方式生活,那么,如果上帝存在,你将得到无尽的福祉；如果上帝不存在,其实你也失去不了什么。但是假设你不相信上帝存在,且不按基督教的方式生活,如果上帝确实不存在,你也不会失去什么；但如果上帝确实存在,你将会受到无尽的惩罚。所以你会发现真正的较劲，不是别人，不是外面，就是你自己。 也就是说生活中很多问题、困难、挑战大多数都是因为自己被自己吓倒了，我说的是大多数，比如你要考雅思或者CFA（美国特许金融分析师），网上一搜，一听说好不简单，好难，于是后面就是自证预言（self-fulfilling prophecy）的过程，你还没去做，你就已经快要失败了。所以不要被自己所吓倒，相信自己！当然你可以选择不相信，要知道现在极度乐观的人都很少，更别说良性乐观的人了。 7 将自己产品化，公司化 Naval，AngelList的CEO，同时也是Twitter的天使投资人在文章How to Get Rich (without getting lucky) by Naval Ravikant 如何（不靠运气）变得富有 中写道：Productize Yourself. 将自己产品化。 当你将自己当做一个产品，看作一家公司，你自己的视角和视野就不一样了，你会考虑如何建立自己人生的 “市场部”——提高情商，学会沟通、“设计部”——良好的个人形象、“技术部”——个人技能的积累训练。具体到一个产品就更不必说了，你和人交往是不是要考虑 “用户体验” ？ 是不是要考虑 “沟通成本” ？ 学会如何营销自己，在有能力的前提下学会曝光自己，让别人看到自己的能力，在职场上也会显现出自己的价值。你是你自己公司的老板，你是 CEO 也是 CFO，同时是 CTO 也是 COO。请学会如何经营自己。 8 人要有自己的笃信 你要有自己的笃行（I do believe）的东西，人要有信念和信仰，比如你笃行Apple、Amazon、Alibaba这些公司的价值一定会不断加大，长期持有这些公司的股票；比如你笃行自己日积月来学习一门外语总有一天可以和老外自然交流，出国随便玩；比如你笃行自己的时间是值钱的，应当将时间花在能够持续产生价值的地方，比如学习一项技能，比如和爱人一起度过一段美好的时光。许知远说：“ 每个人都是带着成见来看待世界的，如果你不带着成见，那么你对这个世界根本就没有看待方式。“ 那你呢？有自己的成见吗？或者有自己所笃行的东西吗？你当然还可以笃行上帝的存在，至少一辈子你要有笃行的东西才行，这是你的价值观，是你之所以为你的东西。 9 学会总结方法论和原则 成功的人总有自己的方法论和原则，比如去年开始在国内上市的 [美] 瑞·达利欧 写的《原则》。 下面我将书中一些重要原则列出来： 人生原则第一部分：拥抱现实，善待现实。例如不要隐藏自己的观点、善于接受他人的意见。其中最重要的一条原则是我们对待错误的态度：痛苦+反思=进步。 人生原则第二部分：通过五步达到你想要的目标：设定目标，识别问题，诊断问题，设计解决方法，执行解决方案。这几步听起来很简单，但大多数人不一定做得到，主要是有两个原因：第一，人类的天性是自负的，我们都希望自己的能力得到他人的认可。第二，每个人都有盲点。 人生原则第三部分：极度开放。正是因为我们有各种各样的局限性，所以我们需要开放地听取他人的意见，尤其是反对的意见，而且最好是你身边的高手提出的反对意见。 人生原则第四部分：要明白每个人都是不同的。比如，有的员工信赖度高，有的员工创新能力强，有的员工执行能力强，每个员工都被打分之后，同事和领导就知道这个员工的优点和缺点在哪里，即便同事之间第一次工作，大家也能做出比较准确的工作预期。 人生原则第五部分：进行有效决策。有一个决策工具叫做“可信度加权决策法”，奉行“优秀想法至上”，而不是“权力至上”，让最优秀的想法脱颖而出，第一步是所有人把想法拿出来给大家看，第二步是大家互相批判提出不同意见，充分考虑到每个人不同的背景，然后对不同专长的人提出的意见赋予不同权重，最后加权计算进行决策。 10 注意力和时间最值钱 20多岁年轻的你可能口袋里是扁扁的，但是大脑不可以穷。对现在的你来说钱不是最最重要的，有两个更加重要的是注意力和时间，越容易被人忽视的东西可能越有价值。年轻的你浪费钱是小事，但是如果你肆意浪费时间并且消磨自己的注意力，后果请充分发挥自己的想象。如果你还在被某条、某音、某宝、某博占用太多的时间，是否愿意停下来思考??一下呢？如果你养成了消耗注意力和时间的习惯，后果自行脑补，你必然会越来越穷。这也就是我自己常给周围人讲的一句话：Distraction and impatience will eat or kill you. （注意力不集中并且缺乏耐心会吞噬你自己。） 11 反人性操作，忌自欺欺人 人性是有很多弱点的（你是不是猜到我会推荐你《人性的弱点》），比如人很多情况下会自己对自己说谎，比如对自己说，某某事情我回头有时间再做，其实回头就忘了，很多人容易高估自己的效率但也同时容易低估自己的潜能。什么是反人性操作？这是我自己杜撰的一个词，是讲：人性本来就是懒惰的，想想七宗罪：暴食、贪婪、懒惰、愤怒、骄傲、淫欲、嫉妒。在投资领域，巴菲特有句著名的话，叫做：“别人贪婪时恐惧,别人恐惧时贪婪”，那么多人追涨杀跌，why？因为受人性本能所支配，而不是大脑控制自己的决定。这就是说投资终究是一场博弈，需要你懂人性，懂心理。广而谈之，如何反人性操作？很简单，大多数人无法自律你就自律，大多数人无法坚持每天锻炼你就锻炼，只要将时间这一变量加入其中，假以时日，相信你一定会有所收获！ 12 圈子，和谁在一起呼吸 著名的商业哲学家吉姆罗恩说，“与你相处时间最长的5个人代表者你的水平。”（You are the average of the five people you spend the most time with.） 中国也有句古话，“近朱者赤”。 你身边的这5个人是谁？谁给你最多的动力和启发？很多网络上的商业鸡汤将其称之为“五人平均值（Average of Five）”理论，强调人们必须经常审视自己的人际关系，你现阶段花最多时间相处的5个人平均下来就是当下的你。这五个人可能是你的伴侣、朋友、同事或你生活中的精神导师，他们的思想、价值观会对你的个性和观念产生重大影响，开拓你的眼界，激励你追逐梦想中的自己。他们其实在影响你的决定在生活中做任何比较有挑战的决定时，我们常常会容易退缩或迷失，如果你最近有一个旅行的计划，但是迟迟因为各种原因无法动身，如果你周围的朋友也热爱旅游，那么他们会建议你立即动身，如果他们特别宅，那么给你的建议也许就是非常消极的。但你可以先做的，其实只是改变周遭环境。改变环境，跳出舒适圈！这个过程中最关键的，不是环境，不是你周围这些优秀的人，而是自己能否持续地取得进步，跟上优秀的人的脚步。不然，也就不会有人一开始的时候优秀上进，到后来却变得平庸堕落。 所以你在什么样的圈子，最终决定了你走到哪里。当然你可以同时在多个优质圈中。 13 合群但是不要合羊群 上面一条提到圈子的重要性，再补充一点：人类是群居动物，到如今我们也脱离不了社交属性。当有一点需要注意就是现在人们普遍强调人要合群，但是这里我向告诉大家合群可以但是不要合羊群，羊群什么特征？一窝蜂地行动，要跑都跑。（大家看看网络上的很多评论很多行为就知道了，无脑跟风）这里其实提到的是训练自己独立思考的能力，影响力的本质是判断力和思考力，想想大咖之所以为大咖，是不是因为他们有自己独到的见解？尤其是投资，更是要有自己独立思考的能力，而不是听消息，就像羊一样。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringCloud注解]]></title>
    <url>%2FSpringCloud%E6%B3%A8%E8%A7%A3.html</url>
    <content type="text"><![CDATA[1. @SpringBootApplication:核心注解@Configuration,@EnableAutoConfiguration,@ComponentScan。由于这些注解一般都是一起使用，spring boot提供了一个统一的注解@SpringBootApplication。 @SpringBootApplication = (默认属性)@Configuration + @EnableAutoConfiguration + @ComponentScan。 分开解释@Configuration,@EnableAutoConfiguration,@ComponentScan。 @Configuration：提到@Configuration就要提到他的搭档@Bean。使用这两个注解就可以创建一个简单的spring配置类，可以用来替代相应的xml配置文件。 123456 &lt;beans&gt; &lt;bean id = &quot;car&quot; class=&quot;com.test.Car&quot;&gt; &lt;property name=&quot;wheel&quot; ref = &quot;wheel&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id = &quot;wheel&quot; class=&quot;com.test.Wheel&quot;&gt;&lt;/bean&gt; &lt;/beans&gt; 相当于： 12345678910111213 @Configuration public class Conf &#123; @Bean public Car car() &#123; Car car = new Car(); car.setWheel(wheel()); return car; &#125; @Bean public Wheel wheel() &#123; return new Wheel(); &#125; &#125; @Configuration的注解类标识这个类可以使用Spring IoC容器作为bean定义的来源。@Bean注解告诉Spring，一个带有@Bean的注解方法将返回一个对象，该对象应该被注册为在Spring应用程序上下文中的bean。 @EnableAutoConfiguration：能够自动配置spring的上下文，试图猜测和配置你想要的bean类，通常会自动根据你的类路径和你的bean定义自动配置。 @ComponentScan：会自动扫描指定包下的全部标有@Component的类，并注册成bean，当然包括@Component下的子注解@Service,@Repository,@Controller。 2. @EnableDiscoveryClient:注册中心注解 @EnableEurekaClient: 该注解表明应用既作为eureka实例又为eureka client 可以发现注册的服务 @EnableEurekaServer: 该注解表明应用为eureka服务，有可以联合多个服务作为集群，对外提供服务注册以及发现功能 SpringCLoud中的“Discovery Service”有多种实现，比如：eureka, consul, zookeeper。 @EnableDiscoveryClient注解是基于spring-cloud-commons依赖，并且在classpath中实现； @EnableEurekaClient注解是基于spring-cloud-netflix依赖，只能为eureka作用； 如果你的classpath中添加了eureka，则它们的作用是一样的。 通过@EnableEurekaClient这个简单的注解，在spring cloud应用启动的时候，就可以把EurekaDiscoveryClient注入，继而使用NetFlix提供的Eureka client。 Eureka是Netflix开源的一款提供服务注册和发现的产品。 Why Eureka?那么为什么我们在项目中使用了Eureka呢？我大致总结了一下，有以下几方面的原因： 它提供了完整的Service Registry和Service Discovery实现 首先是提供了完整的实现，并且也经受住了Netflix自己的生产环境考验，相对使用起来会比较省心。 和Spring Cloud无缝集成 我们的项目本身就使用了Spring Cloud和Spring Boot，同时Spring Cloud还有一套非常完善的开源代码来整合Eureka，所以使用起来非常方便。 另外，Eureka还支持在我们应用自身的容器中启动，也就是说我们的应用启动完之后，既充当了Eureka的角色，同时也是服务的提供者。这样就极大地提高了服务的可用性。 这一点是我们选择Eureka而不是zk、etcd等的主要原因，为了提高配置中心的可用性和降低部署复杂度，我们需要尽可能地减少外部依赖。 Open Source 最后一点是开源，由于代码是开源的，所以非常便于我们了解它的实现原理和排查问题。 3. 其他注解 @EnableFeignClients:服务远程调用注解 Feign是一个声明式的WebService客户端。使用Feign能让编写WebService客户端更加简单，它的使用方法是定义一个接口，然后在接口上添加注解，同时也支持JAX-RS标准的注解。Feign也支持可插拔式的编码器和解码器。SpringCloud对Feign进行了封装，使其支持SpringMVC标准注解和HttpMessageConverters。Feign可以与Eureka和Ribbon组合使用以支持负载均衡。 @EnableCircuitBreaker:开启断路器功能注解 @EnableHystrix:表示启用断路器，断路器依赖于服务注册和发现。 @SpringCloudApplication注解，之前没有提过，通过源码我们看到，它整合了@SpringBootApplication、@EnableDiscoveryClient、@EnableCircuitBreaker，主要目的还是简化配置。这几个注解的具体作用这里就不做详细介绍了，之前的文章已经都介绍过。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Win10护眼色背景设置]]></title>
    <url>%2FWin10%E6%8A%A4%E7%9C%BC%E8%89%B2%E8%83%8C%E6%99%AF%E8%AE%BE%E7%BD%AE.html</url>
    <content type="text"><![CDATA[Win10护眼色背景设置将以下内容复制到文本文档并保存为.bat文件运行即可: 1reg add &quot;HKCU\Control Panel\Colors&quot; /v Window /t REG_SZ /d &quot;202 234 206&quot; /f]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Win10</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CMD一键获取所有连接过的WIFI密码]]></title>
    <url>%2FCMD%E4%B8%80%E9%94%AE%E8%8E%B7%E5%8F%96%E6%89%80%E6%9C%89%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%9A%84WIFI%E5%AF%86%E7%A0%81.html</url>
    <content type="text"><![CDATA[CMD一键获取所有连接过的WIFI密码 以管理员权限运行CMD 输入命令: 1for /f &quot;skip=9 tokens=1,2 delims=:&quot; %i in (&apos;netsh wlan show profiles&apos;) do @echo %j | findstr -i -v echo | netsh wlan show profiles %j key=clear 然后CMD就列出很多行,你以前连接过的wifi信息、加密方式、包括密码]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[疯狂的程序员]]></title>
    <url>%2F%E7%96%AF%E7%8B%82%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%91%98.html</url>
    <content type="text"><![CDATA[疯狂的程序员 要么做第一个，要么做最好的一个。 什么是鸡肋课？就是每个人都在自己课表的这门课旁边标注一个“可旷”或者“选修”。 什么程序优化啊，都抵不上有钱，有钱就是最好的优化。说什么“效率就是金钱”，其实“金钱就是效率”。 中国人和外国人很大不同就在于外国人总想热衷于第一时间把自己的新发现公布出来以此向广大人民群众展示自己的水平。中国人往往喜欢把自己的新发现阴在心里，自己偷偷垄断享用。唯恐被第二个人知道。公布出去，相关部门肯定马上解决。 所谓好的病毒就是要：“持续时间特别长，波及范围特别广，破坏力特别大。” 能进别人系统偷东西，那就是小偷；能进别人系统又不偷东西，那就是黑客。 当你不是黑客的时候，总说：“我是个黑客”。当你真正成为黑客的时候，你往往会说：“我不是黑客” 程序员是值得尊敬的，程序员的双手是魔术师的双手，他们把枯燥无味的代码变成了丰富多彩的软件…… 一个人静静的坐在电脑前写大卖的感觉，那是什么感觉？那就是武林高手闭关修炼的感觉。 一本好书，就像高级武功秘籍一样，哪怕只从里面领悟个一招半式，功力提升起来都是惊人的，眉超风学的那半生不熟的九阴真经就是证明。 所以练武功和写程序一样，不在乎你修炼了几十年还是几百年，也不在乎你少林武当娥眉拜了多少门派，关键是你有没有把一门武艺炼到出神入化的境界。学武艺，最忌讳总想着去追求大而全，你要明白，其实只需要“打狗棍法”这么一招，就足够你掌舵丐帮，受用终生。 -天下武功出少林，天下语言出汇编 提升功力大低有两种方法，一是自己不断写代码，不断完善，不断把自己的代码写好，二是看牛人的代码。牛人的代码实在太高深了，一句看似平凡的语句，也许背后都蕴含着惊天地泣鬼神的智慧。现在你看不出什么端倪，等十年八年之后，你猛然醒悟：啊，原来大牛的代码竟是如此博大精深！ 对男人来说钱什么都不是，但是你没钱，你就失去了让她了解你的机会。对女人来说漂亮什么都不是，但是你不漂亮，你就失去了让他了解你的机会。 人不怕被识破也不怕丢脸，怕就怕被当场识破和当众丢脸。。 力的作用是相互的，你打别人有多疼，自己的手就有多疼。与其大家都疼，还不如最开始就不要下手打。 每个人都期盼着便宜能光顾到自己，就算没有正儿八经地想，多多少少也偷偷的想过，但是有天便宜真的来了，可要小心了。 写程序并不是一辈子都只是写代码。IT这一行是相当广博的，不管你是男的还是女的，不管你技术是初级、中级还是高级，你都能在这行中找到你自己合适的位置。如果你真的用心了，它带给你的会是一生的回报。 男人的工资，和女人的年龄差不多。没钱的时候，最忌讳别人追问自己的工资待遇。可男人的工资，又和女人的年龄不一样。女人要是年轻，别人问她年龄，她自然敢大方地回答。男人的工资呢？要是高了，还是怕别人追问。 “疯狂的程序员”绝对不是靠狂妄和拼命的程序员，而是能够脚踏实地、持续努力的程序员。一个程序员真正做到了这两点，技术上去之后，唯一能够限制他的只有想像力，到那个时候，才算“疯狂的程序员”，这种程序员啊，才能令竞争对手无比恐惧。 技术其实还是我们最需要的东西，以前我们没有过硬的技术，所以疯狂地追求它。现在呢？有了一点技术，便觉得技术不那么重要。如果这样放任下去，等到我们失去技术的那一天，一定会后悔莫及的！]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Hexo+Github一步步搭建属于自己的博客]]></title>
    <url>%2F%E4%BD%BF%E7%94%A8Hexo%2BGithub%E4%B8%80%E6%AD%A5%E6%AD%A5%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2.html</url>
    <content type="text"><![CDATA[使用Hexo+Github一步步搭建属于自己的博客1. 安装Node.js和配置好Node.js环境打开cmd命令行: 1node -v 2. 安装Git和配置好Git环境3. Github账户注册和新建项目项目必须要遵守格式：账户名.github.io，不然接下来会有很多麻烦。并且需要勾选Initialize this repository with a README 4. 安装Hexo12345678 cd E:\develop\hexo输入npm install hexo-cli -g，开始安装Hexo输入hexo -v，检查hexo是否安装成功输入hexo init，初始化该文件夹输入npm install，安装所需要的组件输入hexo g，首次体验Hexo输入hexo s，开启服务器，访问该网址，正式体验Hexo问题：假如页面一直无法跳转，那么可能端口被占用了。此时我们ctrl+c停止服务器，接着输入“hexo server -p 端口号”来改变端口号 5. Hexo配置Git打开博客目录下面的配置文件_config.yml 12345 deploy:type: gitrepo: git@github.com:yuanzi222/yuanzi222.github.io.gitbranch: mastermessage: 6. 生成静态文件并且部署到服务器1hexo g -d 7. 常用hexo命令1234567891011121314151617181920 hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）hexo deploy #部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本缩写： hexo n == hexo new hexo g == hexo generate hexo s == hexo server hexo d == hexo deploy组合命令： hexo s -g #生成并本地预览 hexo d -g #生成并上传 hexo g &amp;&amp; gulp #压缩生成安装next主题: git clone https://github.com/theme-next/hexo-theme-next themes/next 注意: CNAME文件在下次 hexo deploy的时候就消失了，需要重新创建，这样就很繁琐 方法一：每次 hexo d 之后，就去 GitHub 仓库根目录新建 CNAME文件 方法二：在 hexo g 之后， hexo d 之前，把CNAME文件复制到 “\public\” 目录下面，里面写入你要绑定的域名。 方法三（推荐）：将需要上传至github的内容放在source文件夹，例如CNAME、favicon.ico、images等，这样在 hexo d 之后就不会被删除了。 方法四：通过安装插件实现永久保留 1npm install hexo-generator-cname --save 之后在_config.yml中添加一条 12 Plugins:hexo-generator-cname 需要注意的是：如果是在github上建立的CNAME文件，需要先clone到本地，然后安装插件，在deploy上去即可。CNAME只允许一个域名地址。 8. 添加分类模块 新建一个分类页面 1hexo new page categories 你会发现你的source文件夹下有了categorcies/index.md，打开index.md修改为: 123456 ---title: categoriesdate: 2018-07-27 10:57:39type: &quot;categories&quot;comments: false--- 打开 主题配置文件找到menu，将categorcies取消注释 把文章归入分类只需在文章的顶部标题下方添加categories字段，即可自动创建分类名并加入对应的分类中 123 举个栗子：title: 分类测试文章标题categories: 分类名 9. 添加标签模块 新建一个标签页面: 1hexo new page tags 你会发现你的source文件夹下有了tags/index.md，打开index.md修改为: 123456 ---title: tagsdate: 2018-07-27 10:59:57type: &quot;tags&quot;comments: false--- 打开 主题配置文件 找到menu，将tags取消注释 把文章添加标签只需在文章的顶部标题下方添加tags字段，即可自动创建标签名并归入对应的标签中 123456 举个栗子：title: 标签测试文章标题tags: - 标签1 - 标签2 ... 10. 添加关于模块 新建一个关于页面: 1hexo new page about 你会发现你的source文件夹下有了about/index.md，打开index.md文件即可编辑关于你的信息，可以随便编辑。 打开 主题配置文件 找到menu，将about取消注释 11. 头像设置 打开主题配置文件找到Sidebar Avatar字段 123 # Sidebar Avataravatar: url: /images/header.jpg 这是头像的路径，只需把你的头像命名为header.jpg（随便命名）放入themes/next/source/images中，将avatar的路径名改成你的头像名就OK啦！ 实现头像旋转打开\themes\next\source\css_common\components\sidebar\sidebar-author.styl，在里面添加如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960 .site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/ /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.0s ease-out; -moz-transition: -moz-transform 1.0s ease-out; transition: transform 1.0s ease-out;&#125;img:hover &#123; /* 鼠标经过停止头像旋转 -webkit-animation-play-state:paused; animation-play-state:paused;*/ /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);&#125;/* Z 轴旋转动画 */@-webkit-keyframes play &#123; 0% &#123; -webkit-transform: rotateZ(0deg); &#125; 100% &#123; -webkit-transform: rotateZ(-360deg); &#125;&#125;@-moz-keyframes play &#123; 0% &#123; -moz-transform: rotateZ(0deg); &#125; 100% &#123; -moz-transform: rotateZ(-360deg); &#125;&#125;@keyframes play &#123; 0% &#123; transform: rotateZ(0deg); &#125; 100% &#123; transform: rotateZ(-360deg); &#125;&#125; 12. 设置RSS 先安装 hexo-generator-feed 插件 1npm install hexo-generator-feed --save 打开站点配置文件找到Extensions在下面添加 123456789 # RSS订阅feed: type: atom path: atom.xml limit: 20 hub: content: content_limit: 140 content_limit_delim: &apos; &apos; 打开主题配置文件找到rss，设置为 1rss: /atom.xml 13. 在网站底部加上访问量 添加是否开启统计功能的配置 找到next主题的配置文件themes/next/_config.yml 1234 footer:# -------------------------------------------------------------# visitors countcounter: true 修改next主题的模板文件theme/next/layout/_partials/footer.swig,我们在合适的位置加入： 1234567891011121314 &lt;!-- 在网站底部加上访问量和字数 --&gt;&#123;% if theme.footer.counter %&#125; &lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; &lt;span class=&quot;site-pv&quot; title=&quot;总访问量&quot;&gt; &lt;i class=&quot;fa fa-eye&quot;&gt;&lt;/i&gt; &lt;span class=&quot;busuanzi-value&quot; id=&quot;busuanzi_container_site_pv&quot;&gt;总访问量：&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt; &lt;/span&gt; &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;site-uv-md&quot; title=&quot;总访客&quot;&gt; &lt;i class=&quot;fa fa-user&quot;&gt;&lt;/i&gt; &lt;span class=&quot;busuanzi-value&quot; id=&quot;busuanzi_container_site_uv&quot;&gt;总访客：&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人&lt;/span&gt; &lt;/span&gt; &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;&#123;% endif %&#125; 不蒜子有两种统计方法： pv的方式，单个用户连续点击n篇文章，记录n次访问量 12345 &lt;span id=&quot;busuanzi_container_site_pv&quot;&gt; 总访问量： &lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt; 次&lt;/span&gt; uv的方式，单个用户连续点击n篇文章，只记录1次访客数 12345 &lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; 总访客： &lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt; 人&lt;/span&gt; 14. 添加热度、本文字数和阅读时长 /themes/next/layout/_macro/post.swig: 12 &lt;span class=&quot;busuanzi-value&quot; id=&quot;busuanzi_value_page_pv&quot; &gt;&lt;/span&gt;&lt;span&gt;℃&lt;/span&gt; 2 ./themes/next/languages/zh-CN.yml 12 post:views: 热度 安装插件: 1npm install hexo-symbols-count-time --save 在全局配置文件中添加: 123 symbols_count_time:symbols: truetime: true 15. 网站底部字数统计1.安装插件: 1npm install hexo-wordcount --save 2.在/themes/next/layout/_partials/footer.swig文件尾部加上： 1234 &lt;div class=&quot;theme-info&quot;&gt; &lt;i class=&quot;fa fa-pencil&quot;&gt;&lt;/i&gt; &lt;span class=&quot;post-count&quot;&gt;博客全站共&#123;&#123; totalcount(site) &#125;&#125;字&lt;/span&gt;&lt;/div&gt; 3.文章字数统计:在主题的配置文件中，配置如下： 123456 # Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true wordcount: true min2read: true 16. 添加顶部加载条 在/themes/next/layout/_partials/head.swig中添加代码: 12 &lt;script src=&quot;//cdn.bootcss.com/pace/1.0.2/pace.min.js&quot;&gt;&lt;/script&gt;&lt;link href=&quot;//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css&quot; rel=&quot;stylesheet&quot;&gt; 但是，默认的是粉色的，要改变颜色可以在/themes/next/layout/_partials/head.swig文件中添加如下代码（接在刚才link的后面） 12345678910111213 &lt;style&gt; .pace .pace-progress &#123; background: #1E92FB; /*进度条颜色*/ height: 3px; &#125; .pace .pace-progress-inner &#123; box-shadow: 0 0 10px #1E92FB, 0 0 5px #1E92FB; /*阴影颜色*/ &#125; .pace .pace-activity &#123; border-top-color: #1E92FB; /*上边框颜色*/ border-left-color: #1E92FB; /*左边框颜色*/ &#125;&lt;/style&gt; 现在升级最新版的next主题，升级后只需修改主题配置文件(_config.yml)将pace: false改为pace: true就行了，你还可以换不同样式的加载条， 12pace: truepace_theme: pace-theme-minimal 将模块安装到themes/next/source/lib/pace目录： 1git clone https://github.com/theme-next/theme-next-pace themes/next/source/lib/pace 17. 在右上角或者左上角实现fork me on github在http://tholman.com/github-corners/挑选自己喜欢的样式，并复制代码然后粘贴刚才复制的代码到themes/next/layout/_layout.swig文件中(放在的下面)，并把href改为你的github地址 18. 博文压缩 安装插件: 12 npm install gulp -gnpm install gulp-minify-css gulp-uglify gulp-htmlmin gulp-htmlclean gulp --save 在根目录新建gulpfile.js ，并填入以下内容： 123456789101112131415161718192021222324252627282930313233 var gulp = require(&apos;gulp&apos;);var minifycss = require(&apos;gulp-minify-css&apos;);var uglify = require(&apos;gulp-uglify&apos;);var htmlmin = require(&apos;gulp-htmlmin&apos;);var htmlclean = require(&apos;gulp-htmlclean&apos;);// 压缩 public 目录 cssgulp.task(&apos;minify-css&apos;, function() &#123; return gulp.src(&apos;./public/**/*.css&apos;) .pipe(minifycss()) .pipe(gulp.dest(&apos;./public&apos;));&#125;);// 压缩 public 目录 htmlgulp.task(&apos;minify-html&apos;, function() &#123; return gulp.src(&apos;./public/**/*.html&apos;) .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, &#125;)) .pipe(gulp.dest(&apos;./public&apos;))&#125;);// 压缩 public/js 目录 jsgulp.task(&apos;minify-js&apos;, function() &#123; return gulp.src(&apos;./public/**/*.js&apos;) .pipe(uglify()) .pipe(gulp.dest(&apos;./public&apos;));&#125;);// 执行 gulp 命令时执行的任务gulp.task(&apos;default&apos;, [ &apos;minify-html&apos;,&apos;minify-css&apos;,&apos;minify-js&apos;]); 生成博文是执行 hexo g &amp;&amp; gulp 就会根据 gulpfile.js 中的配置，对 public 目录中的静态资源文件进行压缩。 19. DaoVoice实现在线联系1.在http://www.daovoice.io/注册用户,需要邀请码: a43e7bc3 复制粘贴就可以了~! 2.在hexo\themes\next\layout_partials\head\head.swig添加下面的代码: 12345678 &#123;% if theme.daovoice %&#125; &lt;script&gt;(function(i,s,o,g,r,a,m)&#123;i[&quot;DaoVoiceObject&quot;]=r;i[r]=i[r]||function()&#123;(i[r].q=i[r].q||[]).push(arguments)&#125;,i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset=&quot;utf-8&quot;;m.parentNode.insertBefore(a,m)&#125;)(window,document,&quot;script&quot;,(&apos;https:&apos; == document.location.protocol ? &apos;https:&apos; : &apos;http:&apos;) + &quot;//widget.daovoice.io/widget/a43e7bc3.js&quot;,&quot;daovoice&quot;) daovoice(&apos;init&apos;, &#123; app_id: &quot;&#123;&#123;theme.daovoice_app_id&#125;&#125;&quot; &#125;); daovoice(&apos;update&apos;); &lt;/script&gt;&#123;% endif %&#125; 在主题配置文件中添加: 123 # daovoice在线联系daovoice: truedaovoice_app_id: 你的daovoice应用app_id 安装成功后可以在DaoVoice控制台上的聊天设置里设置聊天窗口样式，附上我的设置: 距离右侧像素值：20.0 距离下侧像素值：80.0 20. 添加分享功能主题配置文件添加: 123 baidushare:type: buttonbaidushare: true 代码在: /hexo/themes/next/layout/_macro/post.swig 21. 添加评论功能 打开LeanCloud官网 https://leancloud.cn 注册用户 修改主题配置文件: 12345678910 valine:enable: trueappid: 你的LeanCloud应用appidappkey: 你的LeanCloud应用appkeynotify: false # mail notifier , https://github.com/xCss/Valine/wikiverify: false # Verification codeplaceholder: 老铁，你不想说两句吗?avatar: wavatarguest_info: nick,mail,linkpageSize: 10 22. 添加侧边栏友情链接修改主题配置文件： 123456789101112 # Blog rollslinks_icon: linklinks_title: 友情链接# links_layout: blocklinks_layout: inlinelinks: Web前端导航: http://www.alloyteam.com/nav/ 创造狮导航: http://www.chuangzaoshi.com/code 前端书籍资料: http://www.36zhen.com/t?id=3448 掘金酱: http://e.xitu.io/ V2EX: https://www.v2ex.com/ 印记中文: https://www.v2ex.com/ 23. 添加侧边栏社交链接在图标库 https://fontawesome.com/icons 选择图标,修改主题配置文件： 123 social:GitHub: https://github.com/yuanzi222 || githubE-Mail: mailto:yuanzi_222@126.com || envelope 24. 设置首页不显示全文(只显示预览)修改主题配置文件: 123 auto_excerpt:enable: truelength: 150 25. SEO优化 首先给你的文章生成sitemap文件 12 npm install hexo-generator-sitemap --save #sitemap.xml适合提交给谷歌搜素引擎npm install hexo-generator-baidu-sitemap --save #baidusitemap.xml适合提交百度搜索引擎 然后在站点配置文件_config.yml中添加以下代码 12345 # 自动生成sitemapsitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xml 优化结构 seo搜索引擎优化认为，网站的最佳结构是用户从首页点击三次就可以到达任何一个页面，但是我们使用hexo编译的站点打开文章的url是：sitename/year/mounth/day/title四层的结构，这样的url结构很不利于seo，爬虫就会经常爬不到我们的文章，于是，我们可以将url直接改成sitename/title的形式，并且title最好是用英文，在根目录的配置文件下修改permalink如下： 1234 url: http://你的网站root: /permalink: :title.htmlpermalink_defaults: nofollow标签 给非友情链接的出站链接添加 “nofollow” 标签，nofollow标签是由谷歌领头创新的一个“反垃圾链接”的标签，并被百度、yahoo等各大搜索引擎广泛支持，引用nofollow标签的目的是：用于指示搜索引擎不要追踪（即抓取）网页上的带有nofollow属性的任何出站链接，以减少垃圾链接的分散网站权重。 安装nofollow插件: 1npm install hexo-autonofollow --save 站点配置文件_config.yml添加: 1234 nofollow: enable: true exclude:- yuanzi.com robots.txt文件 在source文件夹中新建文件robots.txt: 1234567891011121314 # hexo robots.txtUser-agent: *Allow: /Allow: /archives/Disallow: /vendors/Disallow: /js/Disallow: /css/Disallow: /fonts/Disallow: /vendors/Disallow: /fancybox/Sitemap: https://www.yuanzi222.com/sitemap.xmlSitemap: https://www.yuanzi222.com/baidusitemap.xml 验证网证 我们到百度站长平台 https://ziyuan.baidu.com/dashboard/index 里面的站长工具里面去验证网站，大概步骤如下： 第一步：输入网站 第二步：站点属性 第三步：验证网站 前两步都很简单，第三步：验证网站有以下三种方法： 文件验证 HTML标签验证 CNAME验证 这里我们选择CNAME验证的方法，加一条解析 链接提交 链接提交有手动和自动两种方法，手动就是每次你有新的链接生成，你就需要手动提交链接到百度，这种方法太麻烦了，不使用。 自动提交有三种方式： 主动推送(实时) 自动推送 sitemap 这里我们选择sitemap方式。 安装hexo的sitemap网站地图生成插件: 1npm install hexo-generator-baidu-sitemap --save 在你的hexo站点的_config.yml添加下面的代码 123 # hexo sitemap网站地图baidusitemap: path: baidusitemap.xml 配置成功后，hexo编译时会在hexo站点根目录生成baidusitemap.xml，部署网站后，提交到百度： 26. 文章置顶+置顶标签 目前已经有修改后支持置顶的仓库，可以直接用以下命令安装。 12npm uninstall hexo-generator-index --save npm install hexo-generator-index-pin-top --save 然后在需要置顶的文章的Front-matter中加上top: true即可。比如下面这篇文章： 1234567---title: 使用Hexo+Github一步步搭建属于自己的博客 date: 2018-07-21 11:26:12 categories: hexo tags: [hexo]top: true--- 设置置顶标志 打开：/blog/themes/next/layout/_macro 目录下的post.swig文件，定位到标签下，插入如下代码： 12345&#123;% if post.top %&#125; &lt;i class=&quot;fa fa-thumb-tack&quot;&gt;&lt;/i&gt; &lt;font color=7D26CD&gt;置顶&lt;/font&gt; &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;&#123;% endif %&#125; 27. 设置skip_render,指定不进行渲染的文件12 skip_render:- google74022f6cb5756d17.htm]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eclipse护眼背景设置]]></title>
    <url>%2FEclipse%E6%8A%A4%E7%9C%BC%E8%83%8C%E6%99%AF%E8%AE%BE%E7%BD%AE.html</url>
    <content type="text"><![CDATA[Eclipse护眼背景设置Windows -&gt; Preference -&gt; General -&gt; Editors -&gt; Test Editors右下角Appearance color options，选中background color，勾掉System Default，点击’color’颜色块，设置为：色调：85。饱和度：123。亮度：205 即可，据说长时间使用可以缓解眼疲劳哦。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Eclipse</tag>
      </tags>
  </entry>
</search>
