<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SpringBoot整合阿里RocketMQ]]></title>
    <url>%2FSpringBoot%E6%95%B4%E5%90%88%E9%98%BF%E9%87%8CRocketMQ.html</url>
    <content type="text"><![CDATA[Git仓库地址：https://github.com/yuanzi222/rocketmq-service.git RocketMQ相关说明可以查看阿里官方文档：https://help.aliyun.com/document_detail/29532.html?spm=a2c4g.11186623.6.542.62ca4fedZtSUO8 SpringBoot整合阿里RocketMQ1.pom.xml引入依赖&lt;dependency> &lt;groupId>com.tft&lt;/groupId> &lt;artifactId>mq&lt;/artifactId> &lt;version>1.0.0-SNAPSHOT&lt;/version> &lt;/dependency> 2.配置文件中添加相应配置# rocketmq config # 阿里云账号管理控制台中创建的 AccessKey，用于身份认证 rocketmq.accessKey= # 阿里云账号管理控制台中创建的 SecretKey，用于身份认证 rocketmq.secretKey= # 组id rocketmq.groupId= # 公网接入点 rocketmq.namesrvAddr= # 消息主题 rocketmq.topic= 3.消息发送方只需要在相应类中注入RocketMQTemplate@RestController public class RocketMQDemoController { @Value("${rocketmq.topic}") private String topic; private static final String WECHAT_MSG_SEND = "wechatMsgSend"; @Autowired private RocketMQTemplate rocketMQTemplate; @RequestMapping("/demo.json") public String demo(String msg) { MessageEvent messageEvent = new MessageEvent(); messageEvent.setTopic(topic); messageEvent.setTag(WECHAT_MSG_SEND); messageEvent.setMsg(msg); rocketMQTemplate.sendAsync(messageEvent); return "ok"; } } 4.消息消费方监听处理类实现，继承AbstractMessageListener类，实现handle方法即可@Service @RocketMQMessageListener(topic = "TEST") public class RocketMQListenerDemo extends AbstractMessageListener { @Override public void handle(String msg, String msgId, String tag) { switch (tag) { case MqTagConstants.WECHAT_MSG_SEND: // 消费消息业务逻辑 System.err.println("消费消息:" + msg); break; default: break; } } } 注意：消息队列 RocketMQ 里的一个消费者 Group ID 代表一个 Consumer 实例群组。 对于大多数分布式应用来说，一个消费者 Group ID 下通常会挂载多个 Consumer 实例。 订阅关系一致指的是同一个消费者 Group ID 下所有 Consumer 实例的处理逻辑必须完全一致。 一旦订阅关系不一致，消息消费的逻辑就会混乱，甚至导致消息丢失。 由于消息队列 RocketMQ 的订阅关系主要由 Topic+Tag 共同组成，因此，保持订阅关系一致意味着同一个消费者 Group ID 下所有的实例需在以下两方面均保持一致： 订阅的 Topic 必须一致； 订阅的 Topic 中的 Tag 必须一致。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SrpingBoot</tag>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式锁]]></title>
    <url>%2F%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.html</url>
    <content type="text"><![CDATA[首先我们先来看一个小例子： 假设某商城有一个商品库存剩10个，用户A想要买6个，用户B想要买5个，在理想状态下，用户A先买走了6了，库存减少6个还剩4个，此时用户B应该无法购买5个，给出数量不足的提示；而在真实情况下，用户A和B同时获取到商品剩10个，A买走6个，在A更新库存之前，B又买走了5个，此时B更新库存，商品还剩5个，这就是典型的电商“秒杀”活动。 从上述例子不难看出，在高并发情况下，如果不做处理将会出现各种不可预知的后果。那么在这种高并发多线程的情况下，解决问题最有效最普遍的方法就是给共享资源或对共享资源的操作加一把锁，来保证对资源的访问互斥。在Java JDK已经为我们提供了这样的锁，利用ReentrantLcok或者synchronized，即可达到资源互斥访问的目的。但是在分布式系统中，由于分布式系统的分布性，即多线程和多进程并且分布在不同机器中，这两种锁将失去原有锁的效果，需要我们自己实现分布式锁——分布式锁。 分布式锁需要具备哪些条件 获取锁和释放锁的性能要好 判断是否获得锁必须是原子性的，否则可能导致多个请求都获取到锁 网络中断或宕机无法释放锁时，锁必须被清楚，不然会发生死锁 可重入一个线程中可以多次获取同一把锁，比如一个线程在执行一个带锁的方法，该方法中又调用了另一个需要相同锁的方法，则该线程可以直接执行调用的方法，而无需重新获得锁； 5.阻塞锁和非阻塞锁，阻塞锁即没有获取到锁，则继续等待获取锁；非阻塞锁即没有获取到锁后，不继续等待，直接返回锁失败。 分布式锁实现方式一、数据库锁1. 基于MySQL锁表该实现方式完全依靠数据库唯一索引来实现，当想要获得锁时，即向数据库中插入一条记录，释放锁时就删除这条记录。这种方式存在以下几个问题： (1) 锁没有失效时间，解锁失败会导致死锁，其他线程无法再获取到锁，因为唯一索引insert都会返回失败。 (2) 只能是非阻塞锁，insert失败直接就报错了，无法进入队列进行重试 (3) 不可重入，同一线程在没有释放锁之前无法再获取到锁 2. 采用乐观锁增加版本号根据版本号来判断更新之前有没有其他线程更新过，如果被更新过，则获取锁失败。 二、缓存锁这里我们主要介绍几种基于redis实现的分布式锁： 1. 基于setnx、expire两个命令来实现基于setnx（set if not exist）的特点，当缓存里key不存在时，才会去set，否则直接返回false。如果返回true则获取到锁，否则获取锁失败，为了防止死锁，我们再用expire命令对这个key设置一个超时时间来避免。但是这里看似完美，实则有缺陷，当我们setnx成功后，线程发生异常中断，expire还没来的及设置，那么就会产生死锁。 解决上述问题有两种方案 第一种是采用redis2.6.12版本以后的set，它提供了一系列选项 EX seconds – 设置键key的过期时间，单位时秒 PX milliseconds – 设置键key的过期时间，单位时毫秒 NX – 只有键key不存在的时候才会设置key的值 XX – 只有键key存在的时候才会设置key的值 第二种采用setnx()，get()，getset()实现，大体的实现过程如下： (1) 线程Asetnx，值为超时的时间戳(t1)，如果返回true，获得锁。 (2) 线程B用get 命令获取t1，与当前时间戳比较，判断是否超时，没超时false，如果已超时执行步骤3 (3) 计算新的超时时间t2，使用getset命令返回t3(这个值可能其他线程已经修改过)，如果t1==t3,获得锁,如果t1!=t3说明锁被其他线程获取了 (4) 获取锁后，处理完业务逻辑，再去判断锁是否超时，如果没超时删除锁，如果已超时，不用处理（防止删除其他线程的锁） 2. RedLock算法redlock算法是redis作者推荐的一种分布式锁实现方式，算法的内容如下： (1) 获取当前时间； (2) 尝试从5个相互独立redis客户端获取锁； (3) 计算获取所有锁消耗的时间，当且仅当客户端从多数节点获取锁，并且获取锁的时间小于锁的有效时间，认为获得锁； (4) 重新计算有效期时间，原有效时间减去获取锁消耗的时间； (5) 删除所有实例的锁 redlock算法相对于单节点redis锁可靠性要更高，但是实现起来条件也较为苛刻。 (1) 必须部署5个节点才能让Redlock的可靠性更强。 (2) 需要请求5个节点才能获取到锁，通过Future的方式，先并发向5个节点请求，再一起获得响应结果，能缩短响应时间，不过还是比单节点redis锁要耗费更多时间。 然后由于必须获取到5个节点中的3个以上，所以可能出现获取锁冲突，即大家都获得了1-2把锁，结果谁也不能获取到锁，这个问题，redis作者借鉴了raft算法的精髓，通过冲突后在随机时间开始，可以大大降低冲突时间，但是这问题并不能很好的避免，特别是在第一次获取锁的时候，所以获取锁的时间成本增加了。 如果5个节点有2个宕机，此时锁的可用性会极大降低，首先必须等待这两个宕机节点的结果超时才能返回，另外只有3个节点，客户端必须获取到这全部3个节点的锁才能拥有锁，难度也加大了。 如果出现网络分区，那么可能出现客户端永远也无法获取锁的情况，介于这种情况，下面我们来看一种更可靠的分布式锁zookeeper锁。 三、zookeeper分布式锁首先我们来了解一下zookeeper的特性，看看它为什么适合做分布式锁， zookeeper是一个为分布式应用提供一致性服务的软件，它内部是一个分层的文件系统目录树结构，规定统一个目录下只能有一个唯一文件名。 数据模型： 永久节点：节点创建后，不会因为会话失效而消失 临时节点：与永久节点相反，如果客户端连接失效，则立即删除节点 顺序节点：与上述两个节点特性类似，如果指定创建这类节点时，zk会自动在节点名后加一个数字后缀，并且是有序的。 监视器（watcher）： 当创建一个节点时，可以注册一个该节点的监视器，当节点状态发生改变时，watch被触发时，ZooKeeper将会向客户端发送且仅发送一条通知，因为watch只能被触发一次。 根据zookeeper的这些特性，我们来看看如何利用这些特性来实现分布式锁： 创建一个锁目录lock 希望获得锁的线程A就在lock目录下，创建临时顺序节点 获取锁目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁 线程B获取所有节点，判断自己不是最小节点，设置监听(watcher)比自己次小的节点（只关注比自己次小的节点是为了防止发生“羊群效应”） 线程A处理完，删除自己的节点，线程B监听到变更事件，判断自己是最小的节点，获得锁。 小结在分布式系统中，共享资源互斥访问问题非常普遍，而针对访问共享资源的互斥问题，常用的解决方案就是使用分布式锁，这里只介绍了几种常用的分布式锁，分布式锁的实现方式还有有很多种，根据业务选择合适的分布式锁，下面对上述几种锁进行一下比较： 数据库锁： 优点：直接使用数据库，使用简单。 缺点：分布式系统大多数瓶颈都在数据库，使用数据库锁会增加数据库负担。 缓存锁： 优点：性能高，实现起来较为方便，在允许偶发的锁失效情况，不影响系统正常使用，建议采用缓存锁。 缺点：通过锁超时机制不是十分可靠，当线程获得锁后，处理时间过长导致锁超时，就失效了锁的作用。 zookeeper锁： 优点：不依靠超时时间释放锁；可靠性高；系统要求高可靠性时，建议采用zookeeper锁。 缺点：性能比不上缓存锁，因为要频繁的创建节点删除节点。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式架构知识体系]]></title>
    <url>%2F%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB.html</url>
    <content type="text"><![CDATA[本文转载自公众号 编程原理 1.问题 1、何为分布式何为微服务？ 2、为什么需要分布式？ 3、分布式核心理论基础，节点、网络、时间、顺序，一致性？ 4、分布式是系统有哪些设计模式？ 5、分布式有哪些类型？ 6、如何实现分布式？ 2.关键词节点，时间，一致性，CAP，ACID，BASE，P2P，机器伸缩，网络变更，负载均衡，限流，鉴权，服务发现，服务编排，降级，熔断，幂等，分库分表，分片分区，自动运维，容错处理，全栈监控，故障恢复，性能调优 3.全文概要随着移动互联网的发展智能终端的普及，计算机系统早就从单机独立工作过渡到多机器协作工作。计算机以集群的方式存在，按照分布式理论的指导构建出庞大复杂的应用服务，也已经深入人心。本文力求从分布式基础理论，架构设计模式，工程应用，部署运维，业界方案这几大方面，介绍基于MSA(微服务架构)的分布式的知识体系大纲。从而对SOA到MSA进化有个立体的认识，从概念上和工具应用上更近一步了解微服务分布式的本质，身临其境的感受如何搭建全套微服务架构的过程。 4.基础理论4.1SOA到MSA的进化SOA面向服务架构由于业务发展到一定层度后，需要对服务进行解耦，进而把一个单一的大系统按逻辑拆分成不同的子系统，通过服务接口来通讯，面向服务的设计模式，最终需要总线集成服务，而且大部分时候还共享数据库，出现单点故障的时候会导致总线层面的故障，更进一步可能会把数据库拖垮，所以才有了更加独立的设计方案的出现。 MSA微服务架构微服务是真正意义上的独立服务，从服务入口到数据持久层，逻辑上都是独立隔离的，无需服务总线来接入，但同时增加了整个分布式系统的搭建和管理难度，需要对服务进行编排和管理，所以伴随着微服务的兴起，微服务生态的整套技术栈也需要无缝接入，才能支撑起微服务的治理理念。 4.2节点与网络节点传统的节点也就是一台单体的物理机，所有的服务都揉进去包括服务和数据库；随着虚拟化的发展，单台物理机往往可以分成多台虚拟机，实现资源利用的最大化，节点的概念也变成单台虚拟机上面服务；近几年容器技术逐渐成熟后，服务已经彻底容器化，也就是节点只是轻量级的容器服务。总体来说，节点就是能提供单位服务的逻辑计算资源的集合。 网络分布式架构的根基就是网络，不管是局域网还是公网，没有网络就无法把计算机联合在一起工作，但是网络也带来了一系列的问题。网络消息的传播有先后,消息丢失和延迟是经常发生的事情，我们定义了三种网络工作模式： 同步网络 节点同步执行 消息延迟有限 高效全局锁&gt; 半同步网络 锁范围放宽&gt; 异步网络 节点独立执行 消息延迟无上限 无全局锁 部分算法不可行 常用网络传输层有两大协议的特点简介：&gt; TCP协议 首先tcp尽管其他可以更快 tcp解决重复和乱序问题&gt; UDP协议 常量数据流 丢包不致命 4.3时间与顺序时间慢速物理时空中，时间独自在流淌着，对于串行的事务来说，很简单的就是跟着时间的脚步走就可以，先来后到的发生。而后我们发明了时钟来刻画以往发生的时间点，时钟让这个世界尽然有序。但是对于分布式世界来说，跟时间打交道着实是一件痛苦的事情。分布式世界里面，我们要协调不同节点之间的先来后到关系，但是不同节点本身承认的时间又各执己见，于是我们创造了网络时间协议（NTP）试图来解决不同节点之间的标准时间，但是NTP本身表现并不如人意，所以我们又构造除了逻辑时钟，最后改进为向量时钟： NTP的一些缺点，无法完全满足分布式下并发任务的协调问题 节点间时间不同步 硬件时钟漂移 线程可能休眠 操作系统休眠 硬件休眠 逻辑时钟 定义事件先来后到 t’ = max(t, t_msg + 1) &gt; 向量时钟 t_i’ = max(t_i, t_msg_i)&gt; 原子钟 顺序有了衡量时间的工具，解决顺序问题自然就是水到渠成了。因为整个分布式的理论基础就是如何协商不同节点的一致性问题，而顺序则是一致性理论的基本概念，所以前文我们才需要花时间介绍衡量时间的刻度和工具。 4.4一致性理论说到一致性理论，我们必须看一张关于一致性强弱对系统建设影响的对比图： 该图对比了不同一致性算法下的事务，性能，错误，延迟的平衡。 强一致性ACID单机环境下我们对传统关系型数据库有苛刻的要求，由于存在网络的延迟和消息丢失，ACID便是保证事务的原则，这四大原则甚至我们都不需要解释出来就耳熟能详了： Atomicity：原子性，一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。 Consistency：一致性，在事务开始之前和事务结束以后，数据库的完整性没有被破坏。 Isolation：隔离性，数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。 Durabilit：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。 分布式一致性CAP分布式环境下，我们无法保证网络的正常连接和信息的传送，于是发展出了CAP/FLP/DLS这三个重要的理论： CAP:分布式计算系统不可能同时确保一致性（Consistency）、可用性（Availablity）和分区容错性（Partition）。 FLP：在异步环境中，如果节点间的网络延迟没有上限，只要有一个恶意的节点存在，就没有算法能在有限的时间内达成共识。 DLS: （1）在一个部分同步网络的模型（也就是说：网络延时有界限但是我们并不知道在哪里）下运行的协议可以容忍1/3任意（换句话说，拜占庭）错误； （2）在一个异步模型中的确定性的协议（没有网络延时上限）不能容错（不过这个论文没有提起随机化算法可以容忍1/3的错误）； （3）同步模型中的协议（网络延时可以保证小于已知d时间）可以，令人吃惊的，达到100%容错，虽然对1/2的节点出错可以发生的情况有所限制 弱一致性BASE多数情况下，其实我们也并非一定要求强一致性，部分业务可以容忍一定程度的延迟一致，所以为了兼顾效率，发展出来了最终一致性理论BASE，BASE是指基本可用（Basically Available）、软状态（ Soft State）、最终一致性（ Eventual Consistency） 基本可用(Basically Available)：基本可用是指分布式系统在出现故障的时候，允许损失部分可用性，即保证核心可用。 软状态(Soft State)：软状态是指允许系统存在中间状态，而该中间状态不会影响系统整体可用性。分布式存储中一般一份数据至少会有三个副本，允许不同节点间副本同步的延时就是软状态的体现。 最终一致性(Eventual Consistency)：最终一致性是指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。弱一致性和强一致性相反，最终一致性是弱一致性的一种特殊情况。 一致性算法分布式架构的核心就在一致性的实现和妥协，那么如何设计一套算法来保证不同节点之间的通信和数据达到无限趋向一致性，就非常重要了。保证不同节点在充满不确定性网络环境下能达成相同副本的一致性是非常困难的，业界对该课题也做了大量的研究。 首先我们要了解一致性的大前提_原则_(CALM): CALM原则的全称是 Consistency and Logical Monotonicity ，主要描述的是分布式系统中单调逻辑与一致性的关系，它的内容如下，参考consistency as logical monotonicity 在分布式系统中，单调的逻辑都能保证 “最终一致性”，这个过程中不需要依赖中心节点的调度 任意分布式系统，如果所有的非单调逻辑都有中心节点调度，那么这个分布式系统就可以实现最终“一致性” 然后再关注分布式系统的数据结构CRDT(Conflict-Free Replicated Data Types)： 我们了解到分布式一些规律原则之后，就要着手考虑如何来实现解决方案，一致性算法的前提是数据结构，或者说一切算法的根基都是数据结构，设计良好的数据结构加上精妙的算法可以高效的解决现实的问题。经过前人不断的探索，我们得知分布式系统被广泛采用的数据结构CRDT。 参考《谈谈CRDT》,A comprehensive study of Convergent and Commutative Replicated Data Types 基于状态(state-based)：即将各个节点之间的CRDT数据直接进行合并，所有节点都能最终合并到同一个状态，数据合并的顺序不会影响到最终的结果。 基于操作(operation-based)：将每一次对数据的操作通知给其他节点。只要节点知道了对数据的所有操作（收到操作的顺序可以是任意的），就能合并到同一个状态。 了解数据结构后，我们需要来关注一下分布式系统的一些重要的_协议_HATs(Highly Available Transactions)，ZAB(Zookeeper Atomic Broadcast)： 参考《高可用事务》，《ZAB协议分析》 最后要学习的是业界主流的一致性_算法_： 说实话具体的算法我也还没完全搞懂，一致性算法是分布式系统最核心本质的内容，这部分的发展也会影响架构的革新，不同场景的应用也催生不同的算法 Paxos：《优雅的Paxos算法》 Raft ：《Raft 一致性算法》 Gossip：《Gossip Visualization》 这一节我们说完分布式系统里面核心理论基础，如何达成不同节点之间的数据一致性，下面我们将会讲到目前都有哪些主流的分布式系统。 5.场景分类5.1文件系统单台计算机的存储始终有上限，随着网络的出现，多台计算机协作存储文件的方案也相继被提出来。最早的分布式文件系统其实也称为网络文件系统，第一个文件服务器在1970年代被发展出来。在1976年迪吉多公司设计出File Access Listener（FAL），而现代分布式文件系统则出自赫赫有名的Google的论文，《The Google File System》奠定了分布式文件系统的基础。现代主流分布式文件系统参考《分布式文件系统对比》,下面列举几个常用的文件系统 HDFS FastDFS Ceph mooseFS 5.2数据库数据库当然也是属于文件系统，主数据增加了事务，检索，擦除等高级特性，所以复杂度又增加了，既要考虑数据一致性也得保证足够的性能。传统关系型数据库为了兼顾事务和性能的特性，在分布式方面的发展有限，非关系型数据库摆脱了事务的强一致性束缚，达到了最终一致性的效果，从而有了飞跃的发展，NoSql(Not Only Sql)也产生了多个架构的数据库类型，包括KV，列式存储，文档类型等。 列式存储：Hbase 文档存储：Elasticsearch，MongoDB KV类型：Redis 关系型：Spanner 5.3计算分布式计算系统构建在分布式存储的基础上，充分发挥分布式系统的数据冗余灾备，多副本高效获取数据的特性，进而并行计算，把原本需要长时间计算的任务拆分成多个任务并行处理，从而提高了计算效率。分布式计算系统在场景上分为离线计算，实时计算和流式计算。 离线：Hadoop 实时：Spark 流式：Storm，Flink/Blink 5.4缓存缓存作为提升性能的利器无处不在，小到CPU缓存架构，大道分布式应用存储。分布式缓存系统提供了热点数据的随机访问机制，大大了提升了访问时间，但是带来的问题是如何保证数据的一致性，引入分布式锁来解决这个问题，主流的分布式存储系统基本就是Redis了 持久化：Redis 非持久化：Memcache 5.5消息分布式消息队列系统是消除异步带来一系列的复杂步骤的一大利器，多线程高并发场景先我们常常要谨慎的去设计业务代码，来保证多线程并发情况下不出现资源竞争导致的死锁问题。而消息队列以一种延迟消费的模式将异步任务都存到队列，然后再逐个消化。 Kafka RabbitMQ RocketMQ ActiveMQ 5.6监控分布式系统从单机到集群的形态发展，复杂度也大大提高，所以对整个系统的监控也是必不可少。 Zookeeper 5.7应用分布式系统的核心模块就是在应用如何处理业务逻辑，应用直接的调用依赖于特定的协议来通信，有基于RPC协议的也有基于通用的HTTP协议。 HSF Dubbo 5.8日志错误对应分布式系统是家常便饭，而且我们设计系统的时候本身就需要把容错作为普遍存在的现象来考虑。那么当出现故障的时候，快速恢复和排查故障就显得非常重要了。分布式日志采集存储和检索则可以给我提供有力的工具来定位请求链路中出现问题的环节。 日志采集：flume 日志存储：ElasticSearch/Solr，SLS 日志定位：Zipkin 5.9账本前文我们提到所谓分布式系统，是迫于单机的性能有限，而堆硬件却又无法无休止的增加，单机堆硬件最终也会遇到性能增长曲线的瓶颈。于是我们才采用了多台计算机来干同样的活，但是这样的分布式系统始终需要中心化的节点来监控或者调度系统的资源，即使该中心节点也可能是多节点组成。而区块链则是真正的区中心化分布式系统，系统里面才有P2P网络协议各自通信，没有真正意义的中心节点，彼此按照区块链节点的算力，权益等机制来协调新区块的产生。 比特币 以太坊 6.设计模式上节我们列举了不同场景下不同分布式系统架构扮演的角色和实现的功能，本节我们更进一步归纳分布式系统设计的时候是如何考虑架构设计的，不同设计方案直接的区别和侧重点，不同场景需要选择合作设计模式，来减少试错的成本，设计分布式系统需要考虑以下的问题。 6.1可用性可用性是系统运行和工作的时间比例，通常以正常运行时间的百分比来衡量。它可能受系统错误，基础架构问题，恶意攻击和系统负载的影响。分布式系统通常为用户提供服务级别协议（SLA），因此应用程序必须设计为最大化可用性。 健康检查：系统实现全链路功能检查，外部工具定期通过公开端点访问系统 负载均衡：使用队列起到削峰作用，作为请求和服务之间的缓冲区，以平滑间歇性的重负载 节流：限制应用级别、租户或整个服务所消耗资源的范围 6.2数据管理数据管理是分布式系统的关键要素，并影响大多数质量的属性。由于性能，可扩展性或可用性等原因，数据通常托管在不同位置和多个服务器上，这可能带来一系列挑战。例如，必须维护数据一致性，并且通常需要跨不同位置同步数据。 缓存：根据需要将数据从数据存储层加载到缓存 CQRS(Command Query Responsibility Segregation)： &nbsp; &nbsp;命令查询职责分离 事件溯源：仅使用追加方式记录域中完整的系列事件 索引表：在经常查询引用的字段上创建索引 物化视图：生成一个或多个数据预填充视图 拆分：将数据拆分为水平的分区或分片 6.3设计与实现良好的设计包括诸如组件设计和部署的一致性，简化管理和开发的可维护性，以及允许组件和子系统用于其他应用程序和其他方案的可重用性等因素。在设计和实施阶段做出的决策对分布式系统和服务质量和总体拥有成本产生巨大影响。 代理：反向代理 适配器： &nbsp; &nbsp;在现代应用程序和遗留系统之间实现适配器层 前后端分离： &nbsp; &nbsp;后端服务提供接口供前端应用程序调用 计算资源整合：将多个相关任务或操作合并到一个计算单元中 配置分离：将配置信息从应用程序部署包中移出到配置中心 网关聚合：使用网关将多个单独的请求聚合到一个请求中 网关卸载：将共享或专用服务功能卸载到网关代理 网关路由：使用单个端点将请求路由到多个服务 领导人选举：通过选择一个实例作为负责管理其他实例管理员，协调分布式系统的云 管道和过滤器：将复杂的任务分解为一系列可以重复使用的单独组件 边车：将应用的监控组件部署到单独的进程或容器中，以提供隔离和封装 静态内容托管：将静态内容部署到CDN，加速访问效率 6.4消息分布式系统需要一个连接组件和服务的消息传递中间件，理想情况是以松散耦合的方式，以便最大限度地提高可伸缩性。异步消息传递被广泛使用，并提供许多好处，但也带来了诸如消息排序，幂等性等挑战 竞争消费者：多线程并发消费 优先级队列： &nbsp; &nbsp;消息队列分优先级，优先级高的先被消费 6.5管理与监控分布式系统在远程数据中心中运行，无法完全控制基础结构，这使管理和监视比单机部署更困难。应用必须公开运行时信息，管理员可以使用这些信息来管理和监视系统，以及支持不断变化的业务需求和自定义，而无需停止或重新部署应用。 6.6性能与扩展性能表示系统在给定时间间隔内执行任何操作的响应性，而可伸缩性是系统处理负载增加而不影响性能或容易增加可用资源的能力。分布式系统通常会遇到变化的负载和活动高峰，特别是在多租户场景中，几乎是不可能预测的。相反，应用应该能够在限制范围内扩展以满足需求高峰，并在需求减少时进行扩展。可伸缩性不仅涉及计算实例，还涉及其他元素，如数据存储，消息队列等。 6.7弹性弹性是指系统能够优雅地处理故障并从故障中恢复。分布式系统通常是多租户，使用共享平台服务，竞争资源和带宽，通过Internet进行通信，以及在商用硬件上运行，意味着出现瞬态和更永久性故障的可能性增加。为了保持弹性，必须快速有效地检测故障并进行恢复。 隔离：将应用程序的元素隔离到池中，以便在其中一个失败时，其他元素将继续运行。 断路器：处理连接到远程服务或资源时可能需要不同时间修复的故障。 补偿交易：撤消一系列步骤执行的工作，这些步骤共同定义最终一致的操作 健康检查：系统实现全链路功能检查，外部工具定期通过公开端点访问系统 重试：通过透明地重试先前失败的操作，使应用程序在尝试连接到服务或网络资源时处理预期的临时故障 6.8安全安全性是系统能够防止在设计使用之外的恶意或意外行为，并防止泄露或丢失信息。分布式系统在受信任的本地边界之外的Internet上运行，通常向公众开放，并且可以为不受信任的用户提供服务。必须以保护应用程序免受恶意攻击，限制仅允许对已批准用户的访问，并保护敏感数据。 联合身份：将身份验证委派给外部身份提供商 看门人： &nbsp; &nbsp;通过使用专用主机实例来保护应用程序和服务，该实例充当客户端与应用程序或服务之间的代理，验证和清理请求，并在它们之间传递请求和数据 代客钥匙：使用为客户端提供对特定资源或服务的受限直接访问的令牌或密钥。 7.工程应用前文我们介绍了分布式系统的核心理论，面临的一些难题和解决问题的折中思路，罗列了现有主流分布式系统的分类，而且归纳了建设分布式系统的一些方法论，那么接下来我们将从工程角度来介绍真刀真枪搭建分布式系统包含的内容和步骤。 7.1资源调度巧妇难为无米之炊，我们一切的软件系统都是构建在硬件服务器的基础上，从最开始的物理机直接部署软件系统，到虚拟机的应用，最后到了资源上云容器化，硬件资源的使用也开始了集约化的管理。本节从对比的是传统运维角色对应的职责范围，在devops环境下，开发运维一体化，我们要实现的也是资源的灵活高效使用。 弹性伸缩过去软件系统随着用户量增加需要增加机器资源的话，传统的方式就是找运维申请机器，然后部署好软件服务接入集群，整个过程依赖的是运维人员的人肉经验，效率低下而且容易出错。微服务分布式则无需人肉增加物理机器，在容器化技术的支撑下，我们只需要申请云资源，然后执行容器脚本即可。 应用扩容 用户激增需要对服务进行扩展，包括自动化扩容，峰值过后的自动缩容 机器下线 对于过时应用，进行应用下线，云平台收回容器宿主资源 机器置换 对于故障机器，可供置换容器宿主资源，服务自动启动，无缝切换 网络管理有了计算资源后，另外最重要的就是网络资源了。在现有的云化背景下，我们几乎不会直接接触到物理的带宽资源，而是直接的由云平台统一管理带宽资源，我们需要的是对网络资源的最大化应用和有效的管理。 域名申请 应用申请配套域名资源的申请，多套域名映射规则的规范 域名变更 域名变更统一平台管理 负载管理 多机应用的访问策略设定 安全外联 基础访问鉴权，拦截非法请求 统一接入 提供统一接入的权限申请平台，提供统一的登录管理 故障快照在系统故障的时候我们第一要务是系统恢复，同时保留案发现场也是非常重要的，资源调度平台则需要有统一的机制保存好故障现场。 现场保留 内存分布，线程数等资源现象的保存，如JavaDump钩子接入 调试接入 采用字节码技术无需入侵业务代码，可以供生产环境现场日志打点调试 7.2流量调度在我们建设好分布式系统后，最先受到考验的关口就是网关了，进而我们需要关注好系统流量的情况，也就是如何对流量的管理，我们追求的是在系统可容纳的流量上限内，把资源留给最优质的流量使用，而把非法恶意的流量挡在门外，这样节省成本的同时确保系统不会被冲击崩溃。 负载均衡负载均衡是我们对服务如何消化流量的通用设计，通常分为物理层的底层协议分流的硬负载均衡和软件层的软负载。负载均衡解决方案已经是业界成熟的方案，我们通常会针对特定业务在不同环境进行优化，常用有如下的负载均衡解决方案 交换机 F5 LVS/ALI-LVS Nginx/Tengine VIPServer/ConfigServer 网关设计负载均衡首当其冲的就是网关，因为中心化集群流量最先打到的地方就是网关了，如果网关扛不住压力的话，那么整个系统将不可用。 高性能 网关设计第一需要考虑的是高性能的流量转发，网关单节点通常能达到上百万的并发流量 分布式 出于流量压力分担和灾备考虑，网关设计同样需要分布式 业务筛选 网关同设计简单的规则，排除掉大部分的恶意流量 流量管理 请求校验 请求鉴权可以把多少非法请求拦截，清洗 数据缓存 多数无状态的请求存在数据热点，所以采用CDN可以把相当大一部分的流量消费掉 流控控制剩下的真实流量我们采用不同的算法来分流请求 流量分配 计数器 队列 漏斗 令牌桶 动态流控* 流量限制 在流量激增的时候，通常我们需要有限流措施来防止系统出现雪崩，那么就需要预估系统的流量上限，然后设定好上限数，但流量增加到一定阈值后，多出来的流量则不会进入系统，通过牺牲部分流量来保全系统的可用性。 7.3服务调度所谓打铁还需自身硬，流量做好了调度管理后，剩下的就是服务自身的健壮性了。分布式系统服务出现故障是常有的事情，甚至我们需要把故障本身当做是分布式服务的一部分。 注册中心我们网络管理一节中介绍了网关，网关是流量的集散地，而注册中心则是服务的根据地。 状态类型 第一好应用服务的状态，通过注册中心就可以检测服务是否可用 生命周期 应用服务不同的状态组成了应用的生命周期 版本管理 集群版本 集群不用应用有自身对应的版本号，由不同服务组成的集群也需要定义大的版本号 版本回滚 在部署异常的时候可以根据大的集群版本进行回滚管理 服务编排服务编排的定义是：通过消息的交互序列来控制各个部分资源的交互。参与交互的资源都是对等的，没有集中的控制。微服务环境下服务众多我们需要有一个总的协调器来协议服务之间的依赖，调用关系，K8S则是我们的不二选择。 K8S Spring Cloud 服务控制前面我们解决了网络的健壮性和效率问题，这节介绍的是如何使我们的服务更加健壮。 发现 资源管理那节我们介绍了从云平台申请了容器宿主资源后，通过自动化脚本就可以启动应用服务，启动后服务则需要发现注册中心，并且把自身的服务信息注册到服务网关，也即是网关接入。注册中心则会监控服务的不同状态，做健康检查，把不可用的服务归类标记。 网关接入 健康检查* 降级 当用户激增的时候，我们首先是在流量端做手脚，也就是限流。当我们发现限流后系统响应变慢了，有可能导致更多的问题时，我们也需要对服务本身做一些操作。服务降级就是把当前不是很核心的功能关闭掉，或者不是很要紧的准确性放宽范围，事后再做一些人工补救。 降低一致性约束 关闭非核心服务 简化功能* 熔断 当我们都做了以上的操作后，还是觉得不放心，那么就需要再进一步操心。熔断是对过载的一种自身保护，犹如我们开关跳闸一样。比如当我们服务不断对数据库进行查询的时候，如果业务问题造成查询问题，这是数据库本身需要熔断来保证不会被应用拖垮，并且访问友好的信息，告诉服务不要再盲目调用了。 闭合状态 半开状态 断开状态 熔断工具- Hystrix* 幂等 我们知道，一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。那么久需要对单次操作赋予一个全局的id来做标识，这样多次请求后我们可以判断来源于同个客户端，避免出现脏数据。 7.4数据调度数据存储最大的挑战就是数据冗余的管理，冗余多了效率变低而且占用资源，副本少了起不到灾备的作用，我们通常的做法是把有转态的请求，通过转态分离，转化为无状态请求。 状态转移分离状态至全局存储，请求转换为无状态流量，比如我们通常会将登陆信息缓存至全局redis中间件，而不需要在多个应用中去冗余用户的登陆数据。 分库分表数据横向扩展 分片分区多副本冗余 7.5自动化运维我们从资源申请管理的时候就介绍到devops的趋势，真正做到开发运维一体化则需要不同的中间件来配合完成。 配置中心全局配置中心按环境来区分，统一管理，减少了多处配置的混乱局面 switch diamend 部署策略微服务分布式部署是家常便饭，如何让我们的服务更好的支撑业务发展，稳健的部署策略是我们首先需要考虑的，如下的部署策略适合不同业务和不同的阶段。 停机部署 滚动部署 蓝绿部署 灰度部署 A/B测试 作业调度任务调度是系统必不可少的一个环节，传统的方式是在Linux机器上配置crond定时任务或者直接在业务代码里面完成调度业务，现在则是成熟的中间件来代替。 SchedulerX Spring定时任务 应用管理运维工作中很大一部分时间需要对应用进行重启，上下线操作，还有日志清理。 应用重启 应用下线 日志清理 7.6容错处理既然我们知道分布式系统故障时家常便饭的事情，那么应对故障的方案也是不可或缺的环节。通常我们有主动和被动的方式来处理，主动是在错误出现的时候，我们试图再试试几次，说不定就成功了，成功的话就可以避免了该次错误。被动方式是错误的事情已经发生了，为了挽回，我们只是做时候处理，把负面影响降到最小。 重试设计重试设计的关键在于设计好重试的时间和次数，如果超过重试次数，或是一段时间，那么重试就没有意义了。开源的项目 spring-retry可以很好的实现我们重试的计划。 事务补偿事务补偿符合我们最终一致性的理念。补偿事务不一定会将系统中的数据返回到原始操作开始时其所处的状态。 相反，它补偿操作失败前由已成功完成的步骤所执行的工作。补偿事务中步骤的顺序不一定与原始操作中步骤的顺序完全相反。 例如，一个数据存储可能比另一个数据存储对不一致性更加敏感，因而补偿事务中撤销对此存储的更改的步骤应该会首先发生。对完成操作所需的每个资源采用短期的基于超时的锁并预先获取这些资源，这样有助于增加总体活动成功的可能性。 仅在获取所有资源后才应执行工作。 锁过期之前必须完成所有操作。 7.7全栈监控由于分布式系统是由众多机器共同协作的系统，而且网络也无法保证完全可用，所以我们需要建设一套对各个环节都能监控的系统，这样我们才能从底层到业务各个层面进行监控，出现意外的时候可以及时修复故障，避免更多的问题出现。 基础层基础层面是对容器资源的监测，包含各个硬件指标的负载情况 CPU，IO，内存，线程，吞吐 中间件分布式系统接入了大量的中间件平台，中间件本身的健康情况也需要监控 应用层 性能监控 应用层面的需要对每个应用服务的实时指标（qps，rt），上下游依赖等进行监控 业务监控 除了应用本身的监控程度，业务监控也是保证系统正常的一个环节，通过设计合理的业务规则，对异常的情况做报警设置 监控链路 zipkin/eagleeye sls goc Alimonitor 7.8故障恢复当故障已经发生后，我们第一要做的是马上消除故障，确保系统服务正常可用，这个时候通常的做回滚操作。 应用回滚应用回滚之前需要保存好故障现场，以便排查原因。 基线回退应用服务回滚后，代码基线也需要revert到前一版本。 版本回滚整体回滚需要服务编排，通过大版本号对集群进行回滚。 7.9性能调优性能优化是分布式系统的大专题，涉及的面非常广，这块简直可以单独拿出来做一个系列来讲，本节就先不展开。本身我们做服务治理的过程也是在性能的优化过程。 分布式锁缓存是解决性能问题的一大利器，理想情况下，每个请求不需要额外计算立刻能获取到结果返回时最快的。小到CPU的三级缓存，大到分布式缓存，缓存无处不在，分布式缓存需要解决的就是数据的一致性，这个时候我们引入了分布式锁的概念，如何处理分布式锁的问题将决定我们获取缓存数据的效率。 高并发多线程编程模式提升了系统的吞吐量，但也同时带来了业务的复杂度。 异步事件驱动的异步编程是一种新的编程模式，摒弃了多线程的复杂业务处理问题，同时能够提升系统的响应效率。 8.总结最后总结一下，如果有可能的话，请尝试使用单节点方式而不是分布式系统。分布式系统伴随着一些失败的操作，为了处理灾难性故障，我们使用备份。为了提高可靠性，我们引入了冗余。分布式系统本质就是一堆机器的协同。而我们要做的就是搞出各种手段来然机器的运行达到预期。这么复杂的系统，需要了解各个环节，各个中间件的接入，是一个非常大的工程。庆幸的是，在微服务背景下，多数基础性的工作已经有人帮我们实现了。前文所描述的分布式架构，在工程实现了是需要用到分布式三件套(Docker+K8S+Srping Cloud)基本就可以构建出来了。 分布式架构核心技术分布图如下： 分布式技术栈使用中间件： 最后用一张图来概括分布式系统的知识体系。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eureka比Zookeeper好在哪里]]></title>
    <url>%2FEureka%E6%AF%94Zookeeper%E5%A5%BD%E5%9C%A8%E5%93%AA%E9%87%8C.html</url>
    <content type="text"><![CDATA[著名的CAP理论指出，一个分布式系统不可能同时满足C(一致性)、A(可用性)和P(分区容错性)。由于分区容错性在是分布式系统中必须要保证的，因此我们只能在A和C之间进行权衡。在此Zookeeper保证的是CP, 而Eureka则是AP。 Zookeeper保证CP当向注册中心查询服务列表时，我们可以容忍注册中心返回的是几分钟以前的注册信息，但不能接受服务直接down掉不可用。也就是说，服务注册功能对可用性的要求要高于一致性。但是zk会出现这样一种情况，当master节点因为网络故障与其他节点失去联系时，剩余节点会重新进行leader选举。问题在于，选举leader的时间太长，30 ~ 120s, 且选举期间整个zk集群都是不可用的，这就导致在选举期间注册服务瘫痪。在云部署的环境下，因网络问题使得zk集群失去master节点是较大概率会发生的事，虽然服务能够最终恢复，但是漫长的选举时间导致的注册长期不可用是不能容忍的。 Eureka保证APEureka看明白了这一点，因此在设计时就优先保证可用性。Eureka各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。而Eureka的客户端在向某个Eureka注册或时如果发现连接失败，则会自动切换至其它节点，只要有一台Eureka还在，就能保证注册服务可用(保证可用性)，只不过查到的信息可能不是最新的(不保证强一致性)。除此之外，Eureka还有一种自我保护机制，如果在15分钟内超过85%的节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了网络故障，此时会出现以下几种情况： Eureka不再从注册列表中移除因为长时间没收到心跳而应该过期的服务 Eureka仍然能够接受新服务的注册和查询请求，但是不会被同步到其它节点上(即保证当前节点依然可用) 当网络稳定时，当前实例新的注册信息会被同步到其它节点中 因此， Eureka可以很好的应对因网络故障导致部分节点失去联系的情况，而不会像zookeeper那样使整个注册服务瘫痪。 总结 Eureka作为单纯的服务注册中心来说要比zookeeper更加“专业”，因为注册服务更重要的是可用性，我们可以接受短期内达不到一致性的状况。不过Eureka目前1.X版本的实现是基于servlet的Java web应用，它的极限性能肯定会受到影响。期待正在开发之中的2.X版本能够从servlet中独立出来成为单独可部署执行的服务。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
        <tag>Eureka</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BIO、NIO与AIO的区别]]></title>
    <url>%2FBIO%E3%80%81NIO%E4%B8%8EAIO%E7%9A%84%E5%8C%BA%E5%88%AB.html</url>
    <content type="text"><![CDATA[这是最基本与简单的I/O操作方式，其根本特性是做完一件事再去做另一件事，一件事一定要等前一件事做完，这很符合程序员传统的顺序来开发思想，因此BIO模型程序开发起来较为简单，易于把握。 但是BIO如果需要同时做很多事情（例如同时读很多文件，处理很多tcp请求等），就需要系统创建很多线程来完成对应的工作，因为BIO模型下一个线程同时只能做一个工作，如果线程在执行过程中依赖于需要等待的资源，那么该线程会长期处于阻塞状态，我们知道在整个操作系统中，线程是系统执行的基本单位，在BIO模型下的线程 阻塞就会导致系统线程的切换，从而对整个系统性能造成一定的影响。当然如果我们只需要创建少量可控的线程，那么采用BIO模型也是很好的选择，但如果在需要考虑高并发的web或者tcp服务器中采用BIO模型就无法应对了，如果系统开辟成千上万的线程，那么CPU的执行时机都会浪费在线程的切换中，使得线程的执行效率大大降低。此外，关于线程这里说一句题外话，在系统开发中线程的生命周期一定要准确控制，在需要一定规模并发的情形下，尽量使用线程池来确保线程创建数目在一个合理的范围之内，切莫编写线程数量创建上限的代码。 NIO (New I/O) 同步非阻塞I/O关于NIO，国内有很多技术博客将英文翻译成No-Blocking I/O，非阻塞I/O模型 ，当然这样就与BIO形成了鲜明的特性对比。NIO本身是基于事件驱动的思想来实现的，其目的就是解决BIO的大并发问题，在BIO模型中，如果需要并发处理多个I/O请求，那就需要多线程来支持，NIO使用了多路复用器机制，以socket使用来说，多路复用器通过不断轮询各个连接的状态，只有在socket有流可读或者可写时，应用程序才需要去处理它，在线程的使用上，就不需要一个连接就必须使用一个处理线程了，而是只是有效请求时（确实需要进行I/O处理时），才会使用一个线程去处理，这样就避免了BIO模型下大量线程处于阻塞等待状态的情景。 相对于BIO的流，NIO抽象出了新的通道（Channel）作为输入输出的通道，并且提供了缓存（Buffer）的支持，在进行读操作时，需要使用Buffer分配空间，然后将数据从Channel中读入Buffer中，对于Channel的写操作，也需要现将数据写入Buffer，然后将Buffer写入Channel中。 如下是NIO方式进行文件拷贝操作的示例，见下图： 通过比较New IO的使用方式我们可以发现，新的IO操作不再面向 Stream来进行操作了，改为了通道Channel，并且使用了更加灵活的缓存区类Buffer，Buffer只是缓存区定义接口， 根据需要，我们可以选择对应类型的缓存区实现类。在java NIO编程中，我们需要理解以下3个对象Channel、Buffer和Selector。 Channel首先说一下Channel，国内大多翻译成“通道”。Channel和IO中的Stream(流)是差不多一个等级的。只不过Stream是单向的，譬如：InputStream, OutputStream。而Channel是双向的，既可以用来进行读操作，又可以用来进行写操作，NIO中的Channel的主要实现有：FileChannel、DatagramChannel、SocketChannel、ServerSocketChannel；通过看名字就可以猜出个所以然来：分别可以对应文件IO、UDP和TCP（Server和Client）。 BufferNIO中的关键Buffer实现有：ByteBuffer、CharBuffer、DoubleBuffer、 FloatBuffer、IntBuffer、 LongBuffer,、ShortBuffer，分别对应基本数据类型: byte、char、double、 float、int、 long、 short。当然NIO中还有MappedByteBuffer, HeapByteBuffer, DirectByteBuffer等这里先不具体陈述其用法细节。 说一下 DirectByteBuffer 与 HeapByteBuffer 的区别？它们 ByteBuffer 分配内存的两种方式。HeapByteBuffer 顾名思义其内存空间在 JVM 的 heap（堆）上分配，可以看做是 jdk 对于 byte[] 数组的封装；而 DirectByteBuffer 则直接利用了系统接口进行内存申请，其内存分配在c heap 中，这样就减少了内存之间的拷贝操作，如此一来，在使用 DirectByteBuffer 时，系统就可以直接从内存将数据写入到 Channel 中，而无需进行 Java 堆的内存申请，复制等操作，提高了性能。既然如此，为什么不直接使用 DirectByteBuffer，还要来个 HeapByteBuffer？原因在于， DirectByteBuffer 是通过full gc来回收内存的，DirectByteBuffer会自己检测情况而调用 system.gc()，但是如果参数中使用了 DisableExplicitGC 那么就无法回收该快内存了，-XX:+DisableExplicitGC标志自动将 System.gc() 调用转换成一个空操作，就是应用中调用 System.gc() 会变成一个空操作，那么如果设置了就需要我们手动来回收内存了，所以DirectByteBuffer使用起来相对于完全托管于 java 内存管理的Heap ByteBuffer 来说更复杂一些，如果用不好可能会引起OOM。Direct ByteBuffer 的内存大小受 -XX:MaxDirectMemorySize JVM 参数控制（默认大小64M），在 DirectByteBuffer 申请内存空间达到该设置大小后，会触发 Full GC。 SelectorSelector 是NIO相对于BIO实现多路复用的基础，Selector 运行单线程处理多个 Channel，如果你的应用打开了多个通道，但每个连接的流量都很低，使用 Selector 就会很方便。例如在一个聊天服务器中。要使用 Selector , 得向 Selector 注册 Channel，然后调用它的 select() 方法。这个方法会一直阻塞到某个注册的通道有事件就绪。一旦这个方法返回，线程就可以处理这些事件，事件的例子有如新的连接进来、数据接收等。 这里我们再来看一个NIO模型下的TCP服务器的实现，我们可以看到Selector 正是NIO模型下 TCP Server 实现IO复用的关键，请仔细理解下段代码while循环中的逻辑，见下图： AIO (Asynchronous I/O) 异步非阻塞I/OJava AIO就是Java作为对异步IO提供支持的NIO.2 ，Java NIO2 (JSR 203)定义了更多的 New I/O APIs， 提案2003提出，直到2011年才发布， 最终在JDK 7中才实现。JSR 203除了提供更多的文件系统操作API(包括可插拔的自定义的文件系统)， 还提供了对socket和文件的异步 I/O操作。 同时实现了JSR-51提案中的socket channel全部功能,包括对绑定， option配置的支持以及多播multicast的实现。 从编程模式上来看AIO相对于NIO的区别在于，NIO需要使用者线程不停的轮询IO对象，来确定是否有数据准备好可以读了，而AIO则是在数据准备好之后，才会通知数据使用者，这样使用者就不需要不停地轮询了。当然AIO的异步特性并不是Java实现的伪异步，而是使用了系统底层API的支持，在Unix系统下，采用了epoll IO模型，而windows便是使用了IOCP模型。关于Java AIO，本篇只做一个抛砖引玉的介绍，如果你在实际工作中用到了，那么可以参考Netty在高并发下使用AIO的相关技术。 总 结IO实质上与线程没有太多的关系，但是不同的IO模型改变了应用程序使用线程的方式，NIO与BIO的出现解决了很多BIO无法解决的并发问题，当然任何技术抛开适用场景都是耍流氓，复杂的技术往往是为了解决简单技术无法解决的问题而设计的，在系统开发中能用常规技术解决的问题，绝不用复杂技术，否则大大增加系统代码的维护难度，学习IT技术不是为了炫技，而是要实实在在解决问题。 AIO是发出IO请求后，由操作系统自己去获取IO权限并进行IO操作；NIO则是发出IO请求后，由线程不断尝试获取IO权限，获取到后通知应用程序自己进行IO操作。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HttpClient、HttpURLConnection、OKHttp和Volley]]></title>
    <url>%2FHttpClient%E3%80%81HttpURLConnection%E3%80%81OKHttp%E5%92%8CVolley.html</url>
    <content type="text"><![CDATA[今天突然想起有必要总结一下市面上通用的一些网络请求方式，主要通过分析其优缺点和性能，为以后选择网络请求连接方式提供支持。现在常用的网络请求方式主要有：HttpClient、HttpURLConnection、OKHttp和Volley。 一、HttpClient：HttpClient 是Apache的一个三方网络框架，网络请求做了完善的封装，api众多，用起来比较方便，开发快。实现比较稳定，bug比较少，但是正式由于其api众多，是我们很难再不破坏兼容性的情况下对其进行扩展。所以，Android团队对提升和优化httpclient积极性并不高。android5.0被废弃，6.0逐渐删除。 二、HttpURLConnectionHttpURLConnection是一个多用途、轻量级的http客户端。它对网络请求的封装没有HttpClient彻底，api比较简单，用起来没有那么方便。但是正是由于此，使得我们能更容易的扩展和优化的HttpURLConnection。不过，再android2.2之前一直存在着一些令人烦的bug，比如一个人可读的inputstream调用它的close方法的时候，会使得连接池实效，通常的做法就是禁用连接池。因此，在android2.2之前建议使用稳定的HttpClient，android2.2之后使用更容易扩展和优化的HttpURLConnection。 三、okhttp 支持Android 2.3及其以上版本； 支持Java JDK 1.7以上版本； okhttp是专注于提升网络连接效率的http客户端。 它能实现同一ip和端口的请求重用一个socket，这种方式能大大降低网络连接的时间，和每次请求都建立socket，再断开socket的方式相比，降低了服务器服务器的压力。 okhttp 对http和https都有良好的支持。 okhttp 不用担心android版本变换的困扰。 成熟的网络请求解决方案，比HttpURLConnection更好用。 缺点，okhttp请求网络切换回来是在线程里面的，不是在主线程，不能直接刷新UI，需要我们手动处理。封装比较麻烦。 四、VolleyVolley是google在2013 io大会上推出的网络通信框架，特别适合处理数据量小，通信频繁的网络操作。优点是内部封装了异步线程，可直接在主线程请求网络，并处理返回的结果。同时可以取消请求，容易扩展。缺点是：面对大数据量的请求，比如下载表现糟糕，不支持https。Volley的底层在针对android2.3以下系统使用httpclicent，在android2.3以上采用HttpUrlConnection请求网络。 本公司的选择：公司使用Volley框架来处理网络请求，但是，当数据量需求越来大的时候，Volley在面对大数据量的网络请求的表现并不好，加上公司大量采用https协议。于是，公司网络请求采用了Volley＋okhttp。正如我们采用这种方式的优势有： okhttp 不用担心android版本变换的困扰。 okhttp 对大数据量的网络请求支持非常好。 okhttp 同时支持http和https okhttp 重用socket连接，网络请求效率非常高。 Volley框架在异步请求的封装非常好，对子线程网络请求，主线程更新UI支持非常好。能像Image-Loader一样轻松加载网络图片。总之，网络请求底层采用okhttp，异步回调使用Volley框架。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>HttpClient</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux SSH各配置项详解]]></title>
    <url>%2FLinux%20SSH%E5%90%84%E9%85%8D%E7%BD%AE%E9%A1%B9%E8%AF%A6%E8%A7%A3.html</url>
    <content type="text"><![CDATA[关于ssh设置的相关总结（ssh最大连接数、ssh连接时长、安全性配置等)，以redhat6.3为例: ssh配置文件在：/etc/ssh/sshd_config可以打开查看相应配置，默认情况下只开放了几个选项，其余全部#屏蔽掉了。 英文手册参考:http://www.openbsd.org/cgi-bin/man.cgi?query=sshd_config 国内有人已经翻译了：（直接贴过来了） sshd_config中文手册:SSHD_CONFIG(5) OpenBSD Programmer’s Manual SSHD_CONFIG(5) 名称sshd_config - OpenSSH SSH 服务器守护进程配置文件 描述sshd(8) 默认从 /etc/ssh/sshd_config 文件(或通过 -f 命令行选项指定的文件)读取配置信息。配置文件是由”指令 值”对组成的，每行一个。空行和以’#’开头的行都将被忽略。如果值中含有空白符或者其他特殊符号，那么可以通过在两边加上双引号(“)进行界定。[注意]值是大小写敏感的，但指令是大小写无关的。 当前所有可以使用的配置指令如下:AcceptEnv指定客户端发送的哪些环境变量将会被传递到会话环境中。[注意]只有SSH-2协议支持环境变量的传递。细节可以参考 ssh_config(5) 中的 SendEnv 配置指令。指令的值是空格分隔的变量名列表(其中可以使用’*’和’?’作为通配符)。也可以使用多个 AcceptEnv 达到同样的目的。需要注意的是，有些环境变量可能会被用于绕过禁止用户使用的环境变量。由于这个原因，该指令应当小心使用。默认是不传递任何环境变量。 AddressFamily指定 sshd(8) 应当使用哪种地址族。取值范围是：”any”(默认)、”inet”(仅IPv4)、”inet6”(仅IPv6)。 AllowGroups这个指令后面跟着一串用空格分隔的组名列表(其中可以使用”*”和”?”通配符)。默认允许所有组登录。如果使用了这个指令，那么将仅允许这些组中的成员登录，而拒绝其它所有组。这里的”组”是指”主组”(primary group)，也就是/etc/passwd文件中指定的组。这里只允许使用组的名字而不允许使用GID。相关的 allow/deny 指令按照下列顺序处理：DenyUsers, AllowUsers, DenyGroups, AllowGroups AllowTcpForwarding是否允许TCP转发，默认值为”yes”。禁止TCP转发并不能增强安全性，除非禁止了用户对shell的访问，因为用户可以安装他们自己的转发器。 AllowUsers这个指令后面跟着一串用空格分隔的用户名列表(其中可以使用”*”和”?”通配符)。默认允许所有用户登录。如果使用了这个指令，那么将仅允许这些用户登录，而拒绝其它所有用户。如果指定了 USER@HOST 模式的用户，那么 USER 和 HOST 将同时被检查。这里只允许使用用户的名字而不允许使用UID。相关的 allow/deny 指令按照下列顺序处理：DenyUsers, AllowUsers, DenyGroups, AllowGroups AuthorizedKeysFile存放该用户可以用来登录的 RSA/DSA 公钥。该指令中可以使用下列根据连接时的实际情况进行展开的符号：%% 表示’%’、%h 表示用户的主目录、%u 表示该用户的用户名。经过扩展之后的值必须要么是绝对路径，要么是相对于用户主目录的相对路径。默认值是”.ssh/authorized_keys”。 Banner将这个指令指定的文件中的内容在用户进行认证前显示给远程用户。这个特性仅能用于SSH-2，默认什么内容也不显示。”none”表示禁用这个特性。 ChallengeResponseAuthentication是否允许质疑-应答(challenge-response)认证。默认值是”yes”。所有 login.conf(5) 中允许的认证方式都被支持。 Ciphers指定SSH-2允许使用的加密算法。多个算法之间使用逗号分隔。可以使用的算法如下：“aes128-cbc”, “aes192-cbc”, “aes256-cbc”, “aes128-ctr”, “aes192-ctr”, “aes256-ctr”,“3des-cbc”, “arcfour128”, “arcfour256”, “arcfour”, “blowfish-cbc”, “cast128-cbc”默认值是可以使用上述所有算法。 ClientAliveCountMaxsshd(8) 在未收到任何客户端回应前最多允许发送多少个”alive”消息。默认值是 3 。到达这个上限后，sshd(8) 将强制断开连接、关闭会话。需要注意的是，”alive”消息与 TCPKeepAlive 有很大差异。“alive”消息是通过加密连接发送的，因此不会被欺骗；而 TCPKeepAlive 却是可以被欺骗的。如果 ClientAliveInterval 被设为 15 并且将 ClientAliveCountMax 保持为默认值，那么无应答的客户端大约会在45秒后被强制断开。这个指令仅可以用于SSH-2协议。 ClientAliveInterval设置一个以秒记的时长，如果超过这么长时间没有收到客户端的任何数据，sshd(8) 将通过安全通道向客户端发送一个”alive”消息，并等候应答。默认值 0 表示不发送”alive”消息。这个选项仅对SSH-2有效。 Compression是否对通信数据进行加密，还是延迟到认证成功之后再对通信数据加密。可用值：”yes”, “delayed”(默认), “no”。 DenyGroups这个指令后面跟着一串用空格分隔的组名列表(其中可以使用”*”和”?”通配符)。默认允许所有组登录。如果使用了这个指令，那么这些组中的成员将被拒绝登录。这里的”组”是指”主组”(primary group)，也就是/etc/passwd文件中指定的组。这里只允许使用组的名字而不允许使用GID。相关的 allow/deny 指令按照下列顺序处理：DenyUsers, AllowUsers, DenyGroups, AllowGroups DenyUsers这个指令后面跟着一串用空格分隔的用户名列表(其中可以使用”*”和”?”通配符)。默认允许所有用户登录。如果使用了这个指令，那么这些用户将被拒绝登录。如果指定了 USER@HOST 模式的用户，那么 USER 和 HOST 将同时被检查。这里只允许使用用户的名字而不允许使用UID。相关的 allow/deny 指令按照下列顺序处理：DenyUsers, AllowUsers, DenyGroups, AllowGroups ForceCommand强制执行这里指定的命令而忽略客户端提供的任何命令。这个命令将使用用户的登录shell执行(shell -c)。这可以应用于 shell 、命令、子系统的完成，通常用于 Match 块中。这个命令最初是在客户端通过 SSH_ORIGINAL_COMMAND 环境变量来支持的。 GatewayPorts是否允许远程主机连接本地的转发端口。默认值是”no”。sshd(8) 默认将远程端口转发绑定到loopback地址。这样将阻止其它远程主机连接到转发端口。GatewayPorts 指令可以让 sshd 将远程端口转发绑定到非loopback地址，这样就可以允许远程主机连接了。“no”表示仅允许本地连接，”yes”表示强制将远程端口转发绑定到统配地址(wildcard address)，“clientspecified”表示允许客户端选择将远程端口转发绑定到哪个地址。 GSSAPIAuthentication是否允许使用基于 GSSAPI 的用户认证。默认值为”no”。仅用于SSH-2。 GSSAPICleanupCredentials是否在用户退出登录后自动销毁用户凭证缓存。默认值是”yes”。仅用于SSH-2。 HostbasedAuthentication这个指令与 RhostsRSAAuthentication 类似，但是仅可以用于SSH-2。推荐使用默认值”no”。推荐使用默认值”no”禁止这种不安全的认证方式。 HostbasedUsesNameFromPacketOnly在开启 HostbasedAuthentication 的情况下，指定服务器在使用 ~/.shosts ~/.rhosts /etc/hosts.equiv 进行远程主机名匹配时，是否进行反向域名查询。“yes”表示 sshd(8) 信任客户端提供的主机名而不进行反向查询。默认值是”no”。 HostKey主机私钥文件的位置。如果权限不对，sshd(8) 可能会拒绝启动。SSH-1默认是 /etc/ssh/ssh_host_key 。SSH-2默认是 /etc/ssh/ssh_host_rsa_key 和 /etc/ssh/ssh_host_dsa_key 。一台主机可以拥有多个不同的私钥。”rsa1”仅用于SSH-1，”dsa”和”rsa”仅用于SSH-2。 IgnoreRhosts是否在 RhostsRSAAuthentication 或 HostbasedAuthentication 过程中忽略 .rhosts 和 .shosts 文件。不过 /etc/hosts.equiv 和 /etc/shosts.equiv 仍将被使用。推荐设为默认值”yes”。 IgnoreUserKnownHosts是否在 RhostsRSAAuthentication 或 HostbasedAuthentication 过程中忽略用户的 ~/.ssh/known_hosts 文件。默认值是”no”。为了提高安全性，可以设为”yes”。 KerberosAuthentication是否要求用户为 PasswordAuthentication 提供的密码必须通过 Kerberos KDC 认证，也就是是否使用Kerberos认证。要使用Kerberos认证，服务器需要一个可以校验 KDC identity 的 Kerberos servtab 。默认值是”no”。 KerberosGetAFSToken如果使用了 AFS 并且该用户有一个 Kerberos 5 TGT，那么开启该指令后，将会在访问用户的家目录前尝试获取一个 AFS token 。默认为”no”。 KerberosOrLocalPasswd如果 Kerberos 密码认证失败，那么该密码还将要通过其它的认证机制(比如 /etc/passwd)。默认值为”yes”。 KerberosTicketCleanup是否在用户退出登录后自动销毁用户的 ticket 。默认值是”yes”。 KeyRegenerationInterval在SSH-1协议下，短命的服务器密钥将以此指令设置的时间为周期(秒)，不断重新生成。这个机制可以尽量减小密钥丢失或者黑客攻击造成的损失。设为 0 表示永不重新生成，默认为 3600(秒)。 ListenAddress指定 sshd(8) 监听的网络地址，默认监听所有地址。可以使用下面的格式： ListenAddresshost|IPv4_addr|IPv6_addrListenAddress host|IPv4_addr:portListenAddress [host|IPv6_addr]:port 如果未指定 port ，那么将使用 Port 指令的值。可以使用多个 ListenAddress 指令监听多个地址。 LoginGraceTime限制用户必须在指定的时限内认证成功，0 表示无限制。默认值是 120 秒。 LogLevel指定 sshd(8) 的日志等级(详细程度)。可用值如下：QUIET, FATAL, ERROR, INFO(默认), VERBOSE, DEBUG, DEBUG1, DEBUG2, DEBUG3DEBUG 与 DEBUG1 等价；DEBUG2 和 DEBUG3 则分别指定了更详细、更罗嗦的日志输出。比 DEBUG 更详细的日志可能会泄漏用户的敏感信息，因此反对使用。 MACs指定允许在SSH-2中使用哪些消息摘要算法来进行数据校验。可以使用逗号分隔的列表来指定允许使用多个算法。默认值(包含所有可以使用的算法)是：hmac-md5,hmac-sha1,umac-64@openssh.com,hmac-ripemd160,hmac-sha1-96,hmac-md5-96 Match引入一个条件块。块的结尾标志是另一个 Match 指令或者文件结尾。如果 Match 行上指定的条件都满足，那么随后的指令将覆盖全局配置中的指令。Match 的值是一个或多个”条件-模式”对。可用的”条件”是：User, Group, Host, Address 。只有下列指令可以在 Match 块中使用：AllowTcpForwarding, Banner,ForceCommand, GatewayPorts, GSSApiAuthentication,KbdInteractiveAuthentication, KerberosAuthentication,PasswordAuthentication, PermitOpen, PermitRootLogin,RhostsRSAAuthentication, RSAAuthentication, X11DisplayOffset,X11Forwarding, X11UseLocalHost MaxAuthTries指定每个连接最大允许的认证次数。默认值是 6 。如果失败认证的次数超过这个数值的一半，连接将被强制断开，且会生成额外的失败日志消息。 MaxStartups最大允许保持多少个未认证的连接。默认值是 10 。到达限制后，将不再接受新连接，除非先前的连接认证成功或超出 LoginGraceTime 的限制。 PasswordAuthentication是否允许使用基于密码的认证。默认为”yes”。 PermitEmptyPasswords是否允许密码为空的用户远程登录。默认为”no”。 PermitOpen指定TCP端口转发允许的目的地，可以使用空格分隔多个转发目标。默认允许所有转发请求。合法的指令格式如下：PermitOpen host:portPermitOpen IPv4_addr:portPermitOpen [IPv6_addr]:port“any”可以用于移除所有限制并允许一切转发请求。 PermitRootLogin是否允许 root 登录。可用值如下：“yes”(默认) 表示允许。”no”表示禁止。“without-password”表示禁止使用密码认证登录。“forced-commands-only”表示只有在指定了 command 选项的情况下才允许使用公钥认证登录。同时其它认证方法全部被禁止。这个值常用于做远程备份之类的事情。 PermitTunnel是否允许 tun(4) 设备转发。可用值如下：“yes”, “point-to-point”(layer 3), “ethernet”(layer 2), “no”(默认)。“yes”同时蕴含着”point-to-point”和”ethernet”。 PermitUserEnvironment指定是否允许 sshd(8) 处理 ~/.ssh/environment 以及 ~/.ssh/authorized_keys 中的 environment= 选项。默认值是”no”。如果设为”yes”可能会导致用户有机会使用某些机制(比如 LD_PRELOAD)绕过访问控制，造成安全漏洞。 PidFile指定在哪个文件中存放SSH守护进程的进程号，默认为 /var/run/sshd.pid 文件。 Port指定 sshd(8) 守护进程监听的端口号，默认为 22 。可以使用多条指令监听多个端口。默认将在本机的所有网络接口上监听，但是可以通过 ListenAddress 指定只在某个特定的接口上监听。 PrintLastLog指定 sshd(8) 是否在每一次交互式登录时打印最后一位用户的登录时间。默认值是”yes”。 PrintMotd指定 sshd(8) 是否在每一次交互式登录时打印 /etc/motd 文件的内容。默认值是”yes”。 Protocol指定 sshd(8) 支持的SSH协议的版本号。‘1’和’2’表示仅仅支持SSH-1和SSH-2协议。”2,1”表示同时支持SSH-1和SSH-2协议。 PubkeyAuthentication是否允许公钥认证。仅可以用于SSH-2。默认值为”yes”。 RhostsRSAAuthentication是否使用强可信主机认证(通过检查远程主机名和关联的用户名进行认证)。仅用于SSH-1。这是通过在RSA认证成功后再检查 ~/.rhosts 或 /etc/hosts.equiv 进行认证的。出于安全考虑，建议使用默认值”no”。 RSAAuthentication是否允许使用纯 RSA 公钥认证。仅用于SSH-1。默认值是”yes”。 ServerKeyBits指定临时服务器密钥的长度。仅用于SSH-1。默认值是 768(位)。最小值是 512 。 StrictModes指定是否要求 sshd(8) 在接受连接请求前对用户主目录和相关的配置文件进行宿主和权限检查。强烈建议使用默认值”yes”来预防可能出现的低级错误。 Subsystem配置一个外部子系统(例如，一个文件传输守护进程)。仅用于SSH-2协议。值是一个子系统的名字和对应的命令行(含选项和参数)。比如”sft /bin/sftp-server”。 SyslogFacility指定 sshd(8) 将日志消息通过哪个日志子系统(facility)发送。有效值是：DAEMON, USER, AUTH(默认), LOCAL0, LOCAL1, LOCAL2, LOCAL3, LOCAL4, LOCAL5, LOCAL6, LOCAL7 TCPKeepAlive指定系统是否向客户端发送 TCP keepalive 消息。默认值是”yes”。这种消息可以检测到死连接、连接不当关闭、客户端崩溃等异常。可以设为”no”关闭这个特性。 UseDNS指定 sshd(8) 是否应该对远程主机名进行反向解析，以检查此主机名是否与其IP地址真实对应。默认值为”yes”。 UseLogin是否在交互式会话的登录过程中使用 login(1) 。默认值是”no”。如果开启此指令，那么 X11Forwarding 将会被禁止，因为 login(1) 不知道如何处理 xauth(1) cookies 。需要注意的是，login(1) 是禁止用于远程执行命令的。如果指定了 UsePrivilegeSeparation ，那么它将在认证完成后被禁用。 UsePrivilegeSeparation是否让 sshd(8) 通过创建非特权子进程处理接入请求的方法来进行权限分离。默认值是”yes”。认证成功后，将以该认证用户的身份创建另一个子进程。这样做的目的是为了防止通过有缺陷的子进程提升权限，从而使系统更加安全。 X11DisplayOffset指定 sshd(8) X11 转发的第一个可用的显示区(display)数字。默认值是 10 。这个可以用于防止 sshd 占用了真实的 X11 服务器显示区，从而发生混淆。 X11Forwarding是否允许进行 X11 转发。默认值是”no”，设为”yes”表示允许。如果允许X11转发并且sshd(8)代理的显示区被配置为在含有通配符的地址(X11UseLocalhost)上监听。那么将可能有额外的信息被泄漏。由于使用X11转发的可能带来的风险，此指令默认值为”no”。需要注意的是，禁止X11转发并不能禁止用户转发X11通信，因为用户可以安装他们自己的转发器。如果启用了 UseLogin ，那么X11转发将被自动禁止。 X11UseLocalhostsshd(8) 是否应当将X11转发服务器绑定到本地loopback地址。默认值是”yes”。sshd 默认将转发服务器绑定到本地loopback地址并将 DISPLAY 环境变量的主机名部分设为”localhost”。这可以防止远程主机连接到 proxy display 。不过某些老旧的X11客户端不能在此配置下正常工作。为了兼容这些老旧的X11客户端，你可以设为”no”。 XAuthLocation指定 xauth(1) 程序的绝对路径。默认值是 /usr/X11R6/bin/xauth 时间格式在 sshd(8) 命令行参数和配置文件中使用的时间值可以通过下面的格式指定：time[qualifier] 。其中的 time 是一个正整数，而 qualifier 可以是下列单位之一：&lt;无&gt; 秒s | S 秒m | M 分钟h | H 小时d | D 天w | W 星期 可以通过指定多个数值来累加时间，比如：1h30m 1 小时 30 分钟 (90 分钟) 文件/etc/ssh/sshd_configsshd(8) 的主配置文件。这个文件的宿主应当是root，权限最大可以是”644”。 参见sshd(8) 作者OpenSSH is a derivative of the original and free ssh 1.2.12 release byTatu Ylonen. Aaron Campbell, Bob Beck, Markus Friedl, Niels Provos, Theode Raadt and Dug Song removed many bugs, re-added newer features and cre-ated OpenSSH. Markus Friedl contributed the support for SSH protocolversions 1.5 and 2.0. Niels Provos and Markus Friedl contributed supportfor privilege separation. OpenBSD 4.2 January 1, 2008 9Vbird网络篇里的说明：1. 关于 SSH Server 的整体设定,包含使用的 port 啦,以及使用的密码演算方式先留意一下,在预设的文件内,只要是被批注的设定值(#),即为『默认值!』 Port 22SSH 预设使用 22 这个 port,也可以使用多个 port,即重复使用 port 这个设定项目! ## 例如想要开放 sshd 在 22 与 443 ,则多加一行内容为: #### Port 443 这样就好了!不过,不建议修改 port number rotocol 1,2选择的 SSH 协议版本,可以是 1 也可以是 2 ,如果要同时支持两者,就必须要使用 2,1 这个分隔了(Protocol 1,2)! ## 目前我们会建议您,直接使用 Protocol 2 即可! ListenAddress 0.0.0.0监听的主机适配卡!举个例子来说,如果您有两个 IP,分别是 192.168.0.100 及 192.168.2.20 ,那么只想要开放 192.168.0.100 时,就可以写如同下面的样式: ListenAddress 192.168.0.100 只监听来自 192.168.0.100 这个 IP 的 SSH 联机。如果不使用设定的话,则预设所有接口均接受 SSH PidFile /var/run/sshd.pid可以放置 SSHD 这个 PID 的文件!左列为默认值 LoginGraceTime 2m当使用者连上 SSH server 之后,会出现输入密码的画面,在该画面中,在多久时间内没有成功连上 SSH server ,就断线!若无单位则预设时间为秒! Compression yes是否可以使用压缩指令?当然可以 2. 说明主机的 Private Key 放置的档案,预设使用下面的档案即可!HostKey /etc/ssh/ssh_host_key ## SSH version 1 使用的私钥HostKey /etc/ssh/ssh_host_rsa_key ## SSH version 2 使用的 RSA 私钥HostKey /etc/ssh/ssh_host_dsa_key ## SSH version 2 使用的 DSA 私钥还记得我们在主机的 SSH 联机流程里面谈到的,这里就是 Host Key 2.1 关于 version 1 的一些设定!KeyRegenerationInterval 1h由前面联机的说明可以知道, version 1 会使用 server 的 Public Key ,那么如果这个 Public Key 被偷的话,岂不完蛋?所以需要每隔一段时间来重新建立一次!这里的时间为秒!不过我们通常都仅使用 version 2 ,所以这个设定可以被忽略喔! ServerKeyBits 768没错!这个就是 Server key 的长度!用默认值即可。 3. 关于登录文件的讯息数据放置与 daemon 的名称!SyslogFacility AUTHPRIV当有人使用 SSH 登入系统的时候,SSH 会记录信息,这个信息要记录在什么 daemon name底下?预设是以 AUTH 来设定的,即是 /var/log/secure 里面!其它可用的 daemon name 为:DAEMON,USER,AUTH,LOCAL0,LOCAL1,LOCAL2,LOCAL3,LOCAL4,LOCAL5, LogLevel INFO登录记录的等级!注意登机信息可参照vbird基础篇详解。 4. 安全设定项目!极重要!4.1 登入设定部分PermitRootLogin no是否允许 root 登入!预设是允许的,但是建议设定成 no! UserLogin no在 SSH 底下本来就不接受 login 这个程序的登入! StrictModes yes当使用者的 host key 改变之后,Server 就不接受联机,可以抵挡部分的木马程序! RSAAuthentication yes是否使用纯的 RSA 认证!?仅针对 version 1 ! PubkeyAuthentication yes是否允许 Public Key ?当然允许啦!仅针对 version 2 AuthorizedKeysFile .ssh/authorized_keys上面这个在设定若要使用不需要密码登入的账号时,那么那个账号的存放密码所在文件名! 这个设定值很重要喔!文件名记一下! 4.2 认证部分RhostsAuthentication no本机系统不使用 .rhosts,因为仅使用 .rhosts 太不安全了,所以这里一定要设定为 no IgnoreRhosts yes是否取消使用 ~/.ssh/.rhosts 来做为认证!当然是! RhostsRSAAuthentication no这个选项是专门给 version 1 用的,使用 rhosts 文件在 /etc/hosts.equiv 配合 RSA 演算方式来进行认证!不要使用啊! HostbasedAuthentication no这个项目与上面的项目类似,不过是给 version 2 使用的! IgnoreUserKnownHosts no是否忽略家目录内的 ~/.ssh/known_hosts 这个文件所记录的主机内容?当然不要忽略,所以这里就是 no 啦! PasswordAuthentication yes密码验证当然是需要的!所以这里写 yes 啰! PermitEmptyPasswords no若上面那一项如果设定为 yes 的话,这一项就最好设定为 no 这个项目在是否允许以空的密码登入!当然不许! ChallengeResponseAuthentication no允许任何的密码认证!所以,任何 login.conf 规定的认证方式,均可适用!但目前我们比较喜欢使用 PAM 模块帮忙管理认证,因此这个选项可以设定为 no 喔! UsePAM yes利用 PAM 管理使用者认证有很多好处,可以记录与管理。所以这里我们建议您使用 UsePAM 且 ChallengeResponseAuthentication 设定为 no 4.3 与 Kerberos有关的参数设定!因为我们没有 Kerberos 主机,所以底下不用设定! #KerberosAuthentication no #KerberosOrLocalPasswd yes #KerberosTicketCleanup yes #KerberosTgtPassing no 4.4 底下是有关在 X-Window 底下使用的相关设定!X11Forwarding yes #X11DisplayOffset 10 #X11UseLocalhost yes 4.5 登入后的项目:PrintMotd no登入后是否显示出一些信息呢?例如上次登入的时间、地点等等,预设是 yes,亦即是打印出 /etc/motd 这个档案的内容。但是,如果为了安全,可以考虑改为 no ! PrintLastLog yes显示上次登入的信息!可以啊!预设也是 yes ! KeepAlive yes一般而言,如果设定这项目的话,那么 SSH Server 会传送 KeepAlive 的讯息给Client 端,以确保两者的联机正常!在这个情况下,任何一端死掉后,SSH 可以立刻知道!而不会有僵尸程序的发生! UsePrivilegeSeparation yes使用者的权限设定项目!就设定为 yes 吧! MaxStartups 10同时允许几个尚未登入的联机画面?当我们连上 SSH ,但是尚未输入密码时,这个时候就是我们所谓的联机画面啦!在这个联机画面中,为了保护主机,所以需要设定最大值,预设最多十个联机画面,而已经建立联机的不计算在这十个当中 4.6 关于使用者抵挡的设定项目:DenyUsers *设定受抵挡的使用者名称,如果是全部的使用者,那就是全部挡吧!若是部分使用者,可以将该账号填入!例如下列! DenyUsers test DenyGroups test与 DenyUsers 相同!仅抵挡几个群组而已! 5. sshd安全配置(防止攻击) 改端口号 Port 10232 指定每个连接最大允许的认证次数 MaxAuthTries 6]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[后端Long类型过大时返回前端js会丢失精度问题的解决办法]]></title>
    <url>%2F%E5%90%8E%E7%AB%AFLong%E7%B1%BB%E5%9E%8B%E8%BF%87%E5%A4%A7%E6%97%B6%E8%BF%94%E5%9B%9E%E5%89%8D%E7%AB%AFjs%E4%BC%9A%E4%B8%A2%E5%A4%B1%E7%B2%BE%E5%BA%A6%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95.html</url>
    <content type="text"><![CDATA[问题描述后端返回给前端的id是18341382392905728，但前端js显示的是18341382392905730(错误的id)。 根本原因我们后端用的雪花算法来生成id，是17位的而js的number类型有个最大值（安全值）。即2的53次方，为9007199254740992。如果超过这个值，那么js会出现不精确的问题。这个值为16位。 解决方法将后端返回参数为Long类型的都转为字符串再返回给前端。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Bug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写给25岁的你和我——90后自白]]></title>
    <url>%2F%E5%86%99%E7%BB%9925%E5%B2%81%E7%9A%84%E4%BD%A0%E5%92%8C%E6%88%91%E2%80%94%E2%80%9490%E5%90%8E%E8%87%AA%E7%99%BD.html</url>
    <content type="text"><![CDATA[20多岁的年轻人， 有没有人想想， 自己30多岁会是什么样子？ 再回头看，过去的几年自己是什么样子？ 我敢想，那你呢？ 「今天我们的聊聊twentysomething，也就是20多岁的年轻人应该明白什么」 学会用习惯和知识武装自己我们的一生都是由许许多多的小习惯构成的，从小时候习惯咬指甲，吃饭时候习惯先洗手后就餐，到长大成人习惯将四季衣服分类叠好放置，习惯见到陌生人给一个善意且真诚的微笑。好的习惯决定了人的一生，从饮食作息习惯到阅读学习习惯，这些习惯在潜移默化中造就了我们自己（The habits you formed shaped youself.）。在这里我就直接将几个个人认为且坚持践行的好习惯（原因就不在此赘述）： 吃饭七分饱。 坚持有氧运动，比如慢跑，骑单车，后期我自己也打算去学学游泳。 学会记录（要有本子和笔，动手写字，电子笔记是辅助），记录生活中一切可记录的东西，时间?开销，金钱开支。 坚持读文章（中文或者英文） 定期去接近大自然，将心放空。 定期看一部电影（包括但不限于美剧，英剧，想想你自己看过哪些国家的电影呢？） 定期写字，写手稿??。 开始脱离手机的控制（我指的是那些被手机奴役的人）。 定期清理个人物品，整理房间（也就是断舍离）。 多喝白开水（或者说只喝），多吃深色蔬菜（不要一味追求口感）。 强制储蓄，记账 学会列清单。 不因自己的存在而影响他人。 下面说说知识，我们从小就被灌输以 “知识就是力量” 这样的结论，当长大成人依然能够用知识武装自己的人便不多了，很多人无法分清上学和学习是两件事情。一说“你看书呢？” “你是学生吧。” 似乎只有学生?才天经地义应该读书，工作上班了就该忙工作。我个人接触理财投资，顶尖投资人都是海量阅读的践行者，注意海量阅读是结果，不是目标。也即是说投资需要具备综合学科的知识，比如著名投资家查理芒格不仅研究投资理论，而且广泛且深入学习包括微观经济学、心理学、法律、数学、生物学和工程学等多领域知识，将领域洞见应用到投资领域。就我们个人来说，其实掌握最少必要知识MRK（Minimum required knowledge）即可，比如数学中的统计概率思想，基本英文阅读能力，金融学经济学常识或者说类似的通识知识，再如心理学，逻辑学。一个受过良好心理学和逻辑训练的人情商和思维能力自然更高。 因此如果将知识水平按百分数来计算，假设一个人英文水平30%，数学知识30%，编程能力50%，金融知识35%，逻辑思维25%，写作技能60%，演讲技能40%，这样技能的叠加，综合下来是非常有竞争力的。投资人，CEO基本上都是多技能综合体。俗话说：“千金在手，不如一技傍身” 就是这个道理。补充一句：学习如何学习以及学习如何读书也是一门学问。 开始记录，感知时间历史上，现实中伟大的人物，或者说厉害的牛人都是对时间极为敏感或者惜时的人。至少在我心中，比如稻盛和夫、本杰明富兰克林、柳比歇夫都是对时间对掌控能力较强的人。其实掌控时间这个说法不太合适，我们应当和时间做朋友，而不是控制它。很多人知道记账，但是鲜有人知道去记录时间的开支，它有什么好处呢？其一让你知道自己做什么事情要需要多久，其二增加自己对时间对敏感度，最后还可以用来反思哪些时间不该花，哪些事情上应该多花些时间。我们都是在时间这个维度下生存的，当你拥有这个维度去做事的时候就会发现时间的美丽，我们逃离不要宇宙时间的如来神掌。任何事情被给予时间这个因素都会发生量变到质变的过程，比如皮肤的衰老，投资的回报（复利效应），一座历史古城被时间所洗礼后的模样。 因此从今天起，找一个笔记本，开始记录自己的时间开支，否则你会成为一个失控的人，一旦时间失控，后面的话我就不讲了。 做一个学生，一年拜一师这一点其实也是我自己的一个可以说是一个习惯也好原则也好。那就是做一个合格的学生，什么是合格的学生？在老师靠谱的情况下，不因老师个人因素而影响自己接受知识。我自己差不多一年会 “拜” 一个老师，其实不是真的去拜，而是每天增加一个可以向其学习的人，一个榜样，一个行业领袖，一个社会名流，往俗了讲就是厉害牛X的人，比如查理芒格、李开复、李笑来、王石、徐小平、王强、俞敏洪、吴晓波、吴军（排序没有先后），个人认为总要有一个人生导师存在你的灵魂深处，必要时可以向他 “求助”——自问自答，反思自我。我常常看这些人的微博，看他们的生活，他们的关注点，毕竟自己见识有限，有这些老师在自己心中感觉非常踏实，而且自己也是有机会见到这些老师。即便不是人生导师，对于行业中的意见领袖也应当给予关注，时刻关注行业动态。你自己可以对自己骄傲的说一声： “我是XXX的学生。” 活着要有自驱力，做自燃人说到自驱力，其实类似稻盛和夫讲：「成为自燃型的人，带着爱去工作！」 物质有“可燃型”、“不燃型”和“自燃型”三种。同样，人也可以分为三种： 第一种是点火就着的“可燃型”的人； 第二种是点火也烧不起来的“不燃型”的人； 第三种是自己就能熊熊燃烧的“自燃型”的人。 想要成就某项事业，就必须成为“自燃型”的人，在热爱自己工作的同时，必须持有明确的目标。 在一个学校或者公司中，或者说生活中，要做一个有自驱力的人，就像四驱赛车???一样，不是靠外在压力要求来做事，做一个积极主动（proactive）的人，主动性人格。有自驱力且积极主动会让你发现新的东西，让领导同事喜欢，和爱人关系也会变得融洽。 关注眼睛看不到的东西永远要清楚我们的认知有限需要不断升级，想想生活中哪些是看得见的东西，哪些是看不见的？（一件事情背后深层的原因是什么？你对金钱对认识如何？宏观经济呢？社会现象呢？）通常来讲，人对看不见或者未能预见的东西认识不足，没有概念。比如时间，比如微信钱包和支付宝余额中的躺着的数字，比如人的情商，但是看到的东西呢？下面是豆瓣网友「沉默是Daisy」写的对《精进》这本书的评论： 作者针对事件值不值得做，提出了两个维度的评价标准： 「收益值」是指该事件带来的收益大小（认知、情感、物质、身体方面的收益皆可计入）； 「半衰期」是指该收益随时间衰减的速度，半衰期长的事件，影响会持续地较久较长。 在这两个维度的交叉情况下，日常事情都可分为四个类： ? 高收益值、长半衰期事件：如找到真爱 ? 高收益值、短半衰期事件：如淘宝一件时髦的衣服 ? 低收益值、长半衰期事件：如阅读一本经典小说 ? 低收益值、短半衰期事件：如漫无目的地刷朋友圈 仔细一想，平时做得最多的，便是「高收益值、短半衰期事件」，其次是「低收益值、短半衰期事件」，而另两类长半衰期事件却做得很少。作者建议尽量少做「短半衰期」的事情，原因是短半衰期事件大多无关紧要，进行过程中纵然爽快，但完成之后眨眼就忘了；反观长半衰期事件，比如阅读经典，效益可以累计和叠加，即使收益低，长此以往也能慢慢积累，有助于成长。 半衰期这个理念涉及化学，在这里用来判断事情，让人耳目一新。从一个全新的角度，看问题马上不一样了，仿佛从原来二维的角度拓宽到三维，个中区别马上看的清楚。人生的目的如果是不断精进，那多做「长半衰期」的事情，才是帮助自己提高的不二之道。 有句话叫：「日拱一卒无有尽,功不唐捐终入海 」，看不到的事情可能是有价值的事情，看不到的事情也可能是我们尚未能够理解的事情，这个世界真实的样子是什么？当我们多读历史，不断更新自己的知识和经验的时候才更容易看清世界本来的样子。 直面恐惧，别被自己吓倒最近看《十三邀》第三季，许知远对话王石，其中王石说到： 孤独感呢，第一点实际上就是你对死亡的一个恐惧和规避。第二点，那就是原来是很多人对你都不了解。但更多的来讲，是你对这个社会的不了解。而这种不了解，造成一种孤独感。如果你愿意去拥抱这个世界，这个世界是接受你的。帕斯卡说：假设你相信上帝存在,并按照基督教的方式生活,那么,如果上帝存在,你将得到无尽的福祉；如果上帝不存在,其实你也失去不了什么。但是假设你不相信上帝存在,且不按基督教的方式生活,如果上帝确实不存在,你也不会失去什么；但如果上帝确实存在,你将会受到无尽的惩罚。所以你会发现真正的较劲，不是别人，不是外面，就是你自己。 也就是说生活中很多问题、困难、挑战大多数都是因为自己被自己吓倒了，我说的是大多数，比如你要考雅思或者CFA（美国特许金融分析师），网上一搜，一听说好不简单，好难，于是后面就是自证预言（self-fulfilling prophecy）的过程，你还没去做，你就已经快要失败了。所以不要被自己所吓倒，相信自己！当然你可以选择不相信，要知道现在极度乐观的人都很少，更别说良性乐观的人了。 将自己产品化，公司化Naval，AngelList的CEO，同时也是Twitter的天使投资人在文章How to Get Rich (without getting lucky) by Naval Ravikant 如何（不靠运气）变得富有 中写道：Productize Yourself. 将自己产品化。 当你将自己当做一个产品，看作一家公司，你自己的视角和视野就不一样了，你会考虑如何建立自己人生的 “市场部”——提高情商，学会沟通、“设计部”——良好的个人形象、“技术部”——个人技能的积累训练。具体到一个产品就更不必说了，你和人交往是不是要考虑 “用户体验” ？ 是不是要考虑 “沟通成本” ？ 学会如何营销自己，在有能力的前提下学会曝光自己，让别人看到自己的能力，在职场上也会显现出自己的价值。你是你自己公司的老板，你是 CEO 也是 CFO，同时是 CTO 也是 COO。请学会如何经营自己。 人要有自己的笃信你要有自己的笃行（I do believe）的东西，人要有信念和信仰，比如你笃行Apple、Amazon、Alibaba这些公司的价值一定会不断加大，长期持有这些公司的股票；比如你笃行自己日积月来学习一门外语总有一天可以和老外自然交流，出国随便玩；比如你笃行自己的时间是值钱的，应当将时间花在能够持续产生价值的地方，比如学习一项技能，比如和爱人一起度过一段美好的时光。许知远说：“ 每个人都是带着成见来看待世界的，如果你不带着成见，那么你对这个世界根本就没有看待方式。“ 那你呢？有自己的成见吗？或者有自己所笃行的东西吗？你当然还可以笃行上帝的存在，至少一辈子你要有笃行的东西才行，这是你的价值观，是你之所以为你的东西。 学会总结方法论和原则成功的人总有自己的方法论和原则，比如去年开始在国内上市的 [美] 瑞·达利欧 写的《原则》。 下面我将书中一些重要原则列出来： 人生原则第一部分：拥抱现实，善待现实。例如不要隐藏自己的观点、善于接受他人的意见。其中最重要的一条原则是我们对待错误的态度：痛苦+反思=进步。 人生原则第二部分：通过五步达到你想要的目标：设定目标，识别问题，诊断问题，设计解决方法，执行解决方案。这几步听起来很简单，但大多数人不一定做得到，主要是有两个原因：第一，人类的天性是自负的，我们都希望自己的能力得到他人的认可。第二，每个人都有盲点。 人生原则第三部分：极度开放。正是因为我们有各种各样的局限性，所以我们需要开放地听取他人的意见，尤其是反对的意见，而且最好是你身边的高手提出的反对意见。 人生原则第四部分：要明白每个人都是不同的。比如，有的员工信赖度高，有的员工创新能力强，有的员工执行能力强，每个员工都被打分之后，同事和领导就知道这个员工的优点和缺点在哪里，即便同事之间第一次工作，大家也能做出比较准确的工作预期。 人生原则第五部分：进行有效决策。有一个决策工具叫做“可信度加权决策法”，奉行“优秀想法至上”，而不是“权力至上”，让最优秀的想法脱颖而出，第一步是所有人把想法拿出来给大家看，第二步是大家互相批判提出不同意见，充分考虑到每个人不同的背景，然后对不同专长的人提出的意见赋予不同权重，最后加权计算进行决策。 注意力和时间最值钱20多岁年轻的你可能口袋里是扁扁的，但是大脑不可以穷。对现在的你来说钱不是最最重要的，有两个更加重要的是注意力和时间，越容易被人忽视的东西可能越有价值。年轻的你浪费钱是小事，但是如果你肆意浪费时间并且消磨自己的注意力，后果请充分发挥自己的想象。如果你还在被某条、某音、某宝、某博占用太多的时间，是否愿意停下来思考??一下呢？如果你养成了消耗注意力和时间的习惯，后果自行脑补，你必然会越来越穷。这也就是我自己常给周围人讲的一句话：Distraction and impatience will eat or kill you. （注意力不集中并且缺乏耐心会吞噬你自己。） 反人性操作，忌自欺欺人人性是有很多弱点的（你是不是猜到我会推荐你《人性的弱点》），比如人很多情况下会自己对自己说谎，比如对自己说，某某事情我回头有时间再做，其实回头就忘了，很多人容易高估自己的效率但也同时容易低估自己的潜能。什么是反人性操作？这是我自己杜撰的一个词，是讲：人性本来就是懒惰的，想想七宗罪：暴食、贪婪、懒惰、愤怒、骄傲、淫欲、嫉妒。在投资领域，巴菲特有句著名的话，叫做：“别人贪婪时恐惧,别人恐惧时贪婪”，那么多人追涨杀跌，why？因为受人性本能所支配，而不是大脑控制自己的决定。这就是说投资终究是一场博弈，需要你懂人性，懂心理。广而谈之，如何反人性操作？很简单，大多数人无法自律你就自律，大多数人无法坚持每天锻炼你就锻炼，只要将时间这一变量加入其中，假以时日，相信你一定会有所收获！ 圈子，和谁在一起呼吸著名的商业哲学家吉姆罗恩说，“与你相处时间最长的5个人代表者你的水平。”（You are the average of the five people you spend the most time with.） 中国也有句古话，“近朱者赤”。 你身边的这5个人是谁？谁给你最多的动力和启发？很多网络上的商业鸡汤将其称之为“五人平均值（Average of Five）”理论，强调人们必须经常审视自己的人际关系，你现阶段花最多时间相处的5个人平均下来就是当下的你。这五个人可能是你的伴侣、朋友、同事或你生活中的精神导师，他们的思想、价值观会对你的个性和观念产生重大影响，开拓你的眼界，激励你追逐梦想中的自己。他们其实在影响你的决定在生活中做任何比较有挑战的决定时，我们常常会容易退缩或迷失，如果你最近有一个旅行的计划，但是迟迟因为各种原因无法动身，如果你周围的朋友也热爱旅游，那么他们会建议你立即动身，如果他们特别宅，那么给你的建议也许就是非常消极的。但你可以先做的，其实只是改变周遭环境。改变环境，跳出舒适圈！这个过程中最关键的，不是环境，不是你周围这些优秀的人，而是自己能否持续地取得进步，跟上优秀的人的脚步。不然，也就不会有人一开始的时候优秀上进，到后来却变得平庸堕落。 所以你在什么样的圈子，最终决定了你走到哪里。当然你可以同时在多个优质圈中。 合群但是不要合羊群上面一条提到圈子的重要性，再补充一点：人类是群居动物，到如今我们也脱离不了社交属性。当有一点需要注意就是现在人们普遍强调人要合群，但是这里我向告诉大家合群可以但是不要合羊群，羊群什么特征？一窝蜂地行动，要跑都跑。（大家看看网络上的很多评论很多行为就知道了，无脑跟风）这里其实提到的是训练自己独立思考的能力，影响力的本质是判断力和思考力，想想大咖之所以为大咖，是不是因为他们有自己独到的见解？尤其是投资，更是要有自己独立思考的能力，而不是听消息，就像羊一样。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringCloud注解]]></title>
    <url>%2FSpringCloud%E6%B3%A8%E8%A7%A3.html</url>
    <content type="text"><![CDATA[1. @SpringBootApplication:核心注解@Configuration,@EnableAutoConfiguration,@ComponentScan。由于这些注解一般都是一起使用，spring boot提供了一个统一的注解@SpringBootApplication。 @SpringBootApplication = (默认属性)@Configuration + @EnableAutoConfiguration + @ComponentScan。 分开解释@Configuration,@EnableAutoConfiguration,@ComponentScan。 @Configuration：提到@Configuration就要提到他的搭档@Bean。使用这两个注解就可以创建一个简单的spring配置类，可以用来替代相应的xml配置文件。 &lt;beans> &lt;bean id = "car" class="com.test.Car"> &lt;property name="wheel" ref = "wheel">&lt;/property> &lt;/bean> &lt;bean id = "wheel" class="com.test.Wheel">&lt;/bean> &lt;/beans> 相当于： @Configuration public class Conf { @Bean public Car car() { Car car = new Car(); car.setWheel(wheel()); return car; } @Bean public Wheel wheel() { return new Wheel(); } } @Configuration的注解类标识这个类可以使用Spring IoC容器作为bean定义的来源。@Bean注解告诉Spring，一个带有@Bean的注解方法将返回一个对象，该对象应该被注册为在Spring应用程序上下文中的bean。 @EnableAutoConfiguration：能够自动配置spring的上下文，试图猜测和配置你想要的bean类，通常会自动根据你的类路径和你的bean定义自动配置。 @ComponentScan：会自动扫描指定包下的全部标有@Component的类，并注册成bean，当然包括@Component下的子注解@Service,@Repository,@Controller。 2. @EnableDiscoveryClient:注册中心注解 @EnableEurekaClient: 该注解表明应用既作为eureka实例又为eureka client 可以发现注册的服务 @EnableEurekaServer: 该注解表明应用为eureka服务，有可以联合多个服务作为集群，对外提供服务注册以及发现功能 SpringCLoud中的“Discovery Service”有多种实现，比如：eureka, consul, zookeeper。 @EnableDiscoveryClient注解是基于spring-cloud-commons依赖，并且在classpath中实现； @EnableEurekaClient注解是基于spring-cloud-netflix依赖，只能为eureka作用； 如果你的classpath中添加了eureka，则它们的作用是一样的。 通过@EnableEurekaClient这个简单的注解，在spring cloud应用启动的时候，就可以把EurekaDiscoveryClient注入，继而使用NetFlix提供的Eureka client。 Eureka是Netflix开源的一款提供服务注册和发现的产品。 Why Eureka?那么为什么我们在项目中使用了Eureka呢？我大致总结了一下，有以下几方面的原因： 它提供了完整的Service Registry和Service Discovery实现 首先是提供了完整的实现，并且也经受住了Netflix自己的生产环境考验，相对使用起来会比较省心。 和Spring Cloud无缝集成 我们的项目本身就使用了Spring Cloud和Spring Boot，同时Spring Cloud还有一套非常完善的开源代码来整合Eureka，所以使用起来非常方便。 另外，Eureka还支持在我们应用自身的容器中启动，也就是说我们的应用启动完之后，既充当了Eureka的角色，同时也是服务的提供者。这样就极大地提高了服务的可用性。 这一点是我们选择Eureka而不是zk、etcd等的主要原因，为了提高配置中心的可用性和降低部署复杂度，我们需要尽可能地减少外部依赖。 Open Source 最后一点是开源，由于代码是开源的，所以非常便于我们了解它的实现原理和排查问题。 3. 其他注解 @EnableFeignClients:服务远程调用注解 Feign是一个声明式的WebService客户端。使用Feign能让编写WebService客户端更加简单，它的使用方法是定义一个接口，然后在接口上添加注解，同时也支持JAX-RS标准的注解。Feign也支持可插拔式的编码器和解码器。SpringCloud对Feign进行了封装，使其支持SpringMVC标准注解和HttpMessageConverters。Feign可以与Eureka和Ribbon组合使用以支持负载均衡。 @EnableCircuitBreaker:开启断路器功能注解 @EnableHystrix:表示启用断路器，断路器依赖于服务注册和发现。 @SpringCloudApplication注解，之前没有提过，通过源码我们看到，它整合了@SpringBootApplication、@EnableDiscoveryClient、@EnableCircuitBreaker，主要目的还是简化配置。这几个注解的具体作用这里就不做详细介绍了，之前的文章已经都介绍过。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CMD一键获取所有连接过的WIFI密码]]></title>
    <url>%2FCMD%E4%B8%80%E9%94%AE%E8%8E%B7%E5%8F%96%E6%89%80%E6%9C%89%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%9A%84WIFI%E5%AF%86%E7%A0%81.html</url>
    <content type="text"><![CDATA[以管理员权限运行CMD 输入命令: for /f "skip=9 tokens=1,2 delims=:" %i in ('netsh wlan show profiles') do @echo %j | findstr -i -v echo | netsh wlan show profiles %j key=clear 然后CMD就列出很多行,你以前连接过的wifi信息、加密方式、包括密码]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Wifi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Win10护眼色背景设置]]></title>
    <url>%2FWin10%E6%8A%A4%E7%9C%BC%E8%89%B2%E8%83%8C%E6%99%AF%E8%AE%BE%E7%BD%AE.html</url>
    <content type="text"><![CDATA[将以下内容复制到文本文档并保存为.bat文件运行即可: reg add "HKCU\Control Panel\Colors" /v Window /t REG_SZ /d "202 234 206" /f]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Win10</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[疯狂的程序员]]></title>
    <url>%2F%E7%96%AF%E7%8B%82%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%91%98.html</url>
    <content type="text"><![CDATA[要么做第一个，要么做最好的一个。 什么是鸡肋课？就是每个人都在自己课表的这门课旁边标注一个“可旷”或者“选修”。 什么程序优化啊，都抵不上有钱，有钱就是最好的优化。说什么“效率就是金钱”，其实“金钱就是效率”。 中国人和外国人很大不同就在于外国人总想热衷于第一时间把自己的新发现公布出来以此向广大人民群众展示自己的水平。中国人往往喜欢把自己的新发现阴在心里，自己偷偷垄断享用。唯恐被第二个人知道。公布出去，相关部门肯定马上解决。 所谓好的病毒就是要：“持续时间特别长，波及范围特别广，破坏力特别大。” 能进别人系统偷东西，那就是小偷；能进别人系统又不偷东西，那就是黑客。 当你不是黑客的时候，总说：“我是个黑客”。当你真正成为黑客的时候，你往往会说：“我不是黑客” 程序员是值得尊敬的，程序员的双手是魔术师的双手，他们把枯燥无味的代码变成了丰富多彩的软件…… 一个人静静的坐在电脑前写大卖的感觉，那是什么感觉？那就是武林高手闭关修炼的感觉。 一本好书，就像高级武功秘籍一样，哪怕只从里面领悟个一招半式，功力提升起来都是惊人的，眉超风学的那半生不熟的九阴真经就是证明。 所以练武功和写程序一样，不在乎你修炼了几十年还是几百年，也不在乎你少林武当娥眉拜了多少门派，关键是你有没有把一门武艺炼到出神入化的境界。学武艺，最忌讳总想着去追求大而全，你要明白，其实只需要“打狗棍法”这么一招，就足够你掌舵丐帮，受用终生。 -天下武功出少林，天下语言出汇编 提升功力大低有两种方法，一是自己不断写代码，不断完善，不断把自己的代码写好，二是看牛人的代码。牛人的代码实在太高深了，一句看似平凡的语句，也许背后都蕴含着惊天地泣鬼神的智慧。现在你看不出什么端倪，等十年八年之后，你猛然醒悟：啊，原来大牛的代码竟是如此博大精深！ 对男人来说钱什么都不是，但是你没钱，你就失去了让她了解你的机会。对女人来说漂亮什么都不是，但是你不漂亮，你就失去了让他了解你的机会。 人不怕被识破也不怕丢脸，怕就怕被当场识破和当众丢脸。。 力的作用是相互的，你打别人有多疼，自己的手就有多疼。与其大家都疼，还不如最开始就不要下手打。 每个人都期盼着便宜能光顾到自己，就算没有正儿八经地想，多多少少也偷偷的想过，但是有天便宜真的来了，可要小心了。 写程序并不是一辈子都只是写代码。IT这一行是相当广博的，不管你是男的还是女的，不管你技术是初级、中级还是高级，你都能在这行中找到你自己合适的位置。如果你真的用心了，它带给你的会是一生的回报。 男人的工资，和女人的年龄差不多。没钱的时候，最忌讳别人追问自己的工资待遇。可男人的工资，又和女人的年龄不一样。女人要是年轻，别人问她年龄，她自然敢大方地回答。男人的工资呢？要是高了，还是怕别人追问。 “疯狂的程序员”绝对不是靠狂妄和拼命的程序员，而是能够脚踏实地、持续努力的程序员。一个程序员真正做到了这两点，技术上去之后，唯一能够限制他的只有想像力，到那个时候，才算“疯狂的程序员”，这种程序员啊，才能令竞争对手无比恐惧。 技术其实还是我们最需要的东西，以前我们没有过硬的技术，所以疯狂地追求它。现在呢？有了一点技术，便觉得技术不那么重要。如果这样放任下去，等到我们失去技术的那一天，一定会后悔莫及的！]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown代码块支持的语言]]></title>
    <url>%2FMarkdown%E4%BB%A3%E7%A0%81%E5%9D%97%E6%94%AF%E6%8C%81%E7%9A%84%E8%AF%AD%E8%A8%80.html</url>
    <content type="text"><![CDATA[支持高亮显示的语言支持的语言：1c, abnf, accesslog, actionscript, ada, apache, applescript, arduino, armasm, asciidoc, aspectj, autohotkey, autoit, avrasm, awk, axapta, bash, basic, bnf, brainfuck, cal, capnproto, ceylon, clean, clojure, clojure-repl, cmake, coffeescript, coq, cos, cpp, crmsh, crystal, cs, csp, css, d, dart, delphi, diff, django, dns, dockerfile, dos, dsconfig, dts, dust, ebnf, elixir, elm, erb, erlang, erlang-repl, excel, fix, flix, fortran, fsharp, gams, gauss, gcode, gherkin, glsl, go, golo, gradle, groovy, haml, handlebars, haskell, haxe, hsp, htmlbars, http, hy, inform7, ini, irpf90, java, javascript, json, julia, kotlin, lasso, ldif, leaf, less, lisp, livecodeserver, livescript, llvm, lsl, lua, makefile, markdown, mathematica, matlab, maxima, mel, mercury, mipsasm, mizar, mojolicious, monkey, moonscript, n1ql, nginx, nimrod, nix, nsis, objectivec, ocaml, openscad, oxygene, parser3, perl, pf, php, pony, powershell, processing, profile, prolog, protobuf, puppet, purebasic, python, q, qml, r, rib, roboconf, rsl, ruby, ruleslanguage, rust, scala, scheme, scilab, scss, smali, smalltalk, sml, sqf, sql, stan, stata, step21, stylus, subunit, swift, taggerscript, tap, tcl, tex, thrift, tp, twig, typescript, vala, vbnet, vbscript, vbscript-html, verilog, vhdl, vim, x86asm, xl, xml, xquery, yaml, zephir 名称 关键字 调用的js 说明 AppleScript applescript shBrushAppleScript.js ActionScript 3.0 actionscript3 , as3 shBrushAS3.js Shell bash , shell shBrushBash.js ColdFusion coldfusion , cf shBrushColdFusion.js C cpp , c shBrushCpp.js C# c# , c-sharp , csharp shBrushCSharp.js CSS css shBrushCss.js Delphi delphi , pascal , pas shBrushDelphi.js diff&amp;patch diff patch shBrushDiff.js 用代码版本库时,遇到代码冲突,其语法就是这个. Erlang erl , erlang shBrushErlang.js Groovy groovy shBrushGroovy.js Java java shBrushJava.js JavaFX jfx , javafx shBrushJavaFX.js JavaScript js , jscript , javascript shBrushJScript.js Perl perl , pl , Perl shBrushPerl.js PHP php shBrushPhp.js text text , plain shBrushPlain.js 就是普通文本. Python py , python shBrushPython.js Ruby ruby , rails , ror , rb shBrushRuby.js SASS&amp;SCSS sass , scss shBrushSass.js Scala scala shBrushScala.js SQL sql shBrushSql.js Visual Basic vb , vbnet shBrushVb.js XML xml , xhtml , xslt , html shBrushXml.js Objective C objc , obj-c shBrushObjectiveC.js F# f# f-sharp , fsharp shBrushFSharp.js xpp , dynamics-xpp shBrushDynamics.js R r , s , splus shBrushR.js matlab matlab shBrushMatlab.js swift swift shBrushSwift.js GO go , golang shBrushGo.js 用法 ```java代码块```]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eclipse护眼背景设置]]></title>
    <url>%2FEclipse%E6%8A%A4%E7%9C%BC%E8%83%8C%E6%99%AF%E8%AE%BE%E7%BD%AE.html</url>
    <content type="text"><![CDATA[Windows -&gt; Preference -&gt; General -&gt; Editors -&gt; Test Editors右下角Appearance color options，选中background color，勾掉System Default，点击’color’颜色块，设置为：色调：85。饱和度：123。亮度：205 即可，据说长时间使用可以缓解眼疲劳哦。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Eclipse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Hexo+Github一步步搭建属于自己的博客]]></title>
    <url>%2F%E4%BD%BF%E7%94%A8Hexo%2BGithub%E4%B8%80%E6%AD%A5%E6%AD%A5%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2.html</url>
    <content type="text"><![CDATA[1. 安装Node.js和配置好Node.js环境打开cmd命令行: node -v 2. 安装Git和配置好Git环境3. Github账户注册和新建项目项目必须要遵守格式：账户名.github.io，不然接下来会有很多麻烦。并且需要勾选Initialize this repository with a README 4. 安装Hexocd E:\develop\hexo 输入npm install hexo-cli -g，开始安装Hexo 输入hexo -v，检查hexo是否安装成功 输入hexo init，初始化该文件夹 输入npm install，安装所需要的组件 输入hexo g，首次体验Hexo 输入hexo s，开启服务器，访问该网址，正式体验Hexo 问题：假如页面一直无法跳转，那么可能端口被占用了。此时我们ctrl+c停止服务器，接着输入“hexo server -p 端口号”来改变端口号 5. Hexo配置Git打开博客目录下面的配置文件_config.yml deploy: type: git repo: git@github.com:yuanzi222/yuanzi222.github.io.git branch: master message: 6. 生成静态文件并且部署到服务器hexo g -d 7. 常用hexo命令hexo new "postName" #新建文章 hexo new page "pageName" #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server） hexo deploy #部署到GitHub hexo help # 查看帮助 hexo version #查看Hexo的版本 缩写： hexo n == hexo new hexo g == hexo generate hexo s == hexo server hexo d == hexo deploy 组合命令： hexo s -g #生成并本地预览 hexo d -g #生成并上传 hexo g &amp;&amp; gulp #压缩生成 安装next主题: git clone https://github.com/theme-next/hexo-theme-next themes/next 注意: CNAME文件在下次 hexo deploy的时候就消失了，需要重新创建，这样就很繁琐 方法一：每次 hexo d 之后，就去 GitHub 仓库根目录新建 CNAME文件 方法二：在 hexo g 之后， hexo d 之前，把CNAME文件复制到 “\public\” 目录下面，里面写入你要绑定的域名。 方法三（推荐）：将需要上传至github的内容放在source文件夹，例如CNAME、favicon.ico、images等，这样在 hexo d 之后就不会被删除了。 方法四：通过安装插件实现永久保留 npm install hexo-generator-cname --save 之后在_config.yml中添加一条 Plugins: hexo-generator-cname 需要注意的是：如果是在github上建立的CNAME文件，需要先clone到本地，然后安装插件，在deploy上去即可。CNAME只允许一个域名地址。 8. 添加分类模块 新建一个分类页面 hexo new page categories 你会发现你的source文件夹下有了categorcies/index.md，打开index.md修改为: --- title: categories date: 2018-07-27 10:57:39 type: "categories" comments: false --- 打开 主题配置文件找到menu，将categorcies取消注释 把文章归入分类只需在文章的顶部标题下方添加categories字段，即可自动创建分类名并加入对应的分类中 举个栗子： title: 分类测试文章标题 categories: 分类名 9. 添加标签模块 新建一个标签页面: hexo new page tags 你会发现你的source文件夹下有了tags/index.md，打开index.md修改为: --- title: tags date: 2018-07-27 10:59:57 type: "tags" comments: false --- 打开 主题配置文件 找到menu，将tags取消注释 把文章添加标签只需在文章的顶部标题下方添加tags字段，即可自动创建标签名并归入对应的标签中 举个栗子： title: 标签测试文章标题 tags: - 标签1 - 标签2 ... 10. 添加关于模块 新建一个关于页面: hexo new page about 你会发现你的source文件夹下有了about/index.md，打开index.md文件即可编辑关于你的信息，可以随便编辑。 打开 主题配置文件 找到menu，将about取消注释 11. 头像设置 打开主题配置文件找到Sidebar Avatar字段 # Sidebar Avatar avatar: url: /images/header.jpg 这是头像的路径，只需把你的头像命名为header.jpg（随便命名）放入themes/next/source/images中，将avatar的路径名改成你的头像名就OK啦！ 实现头像旋转打开\themes\next\source\css_common\components\sidebar\sidebar-author.styl，在里面添加如下代码： .site-author-image { display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/ /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.0s ease-out; -moz-transition: -moz-transform 1.0s ease-out; transition: transform 1.0s ease-out; } img:hover { /* 鼠标经过停止头像旋转 -webkit-animation-play-state:paused; animation-play-state:paused;*/ /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg); } /* Z 轴旋转动画 */ @-webkit-keyframes play { 0% { -webkit-transform: rotateZ(0deg); } 100% { -webkit-transform: rotateZ(-360deg); } } @-moz-keyframes play { 0% { -moz-transform: rotateZ(0deg); } 100% { -moz-transform: rotateZ(-360deg); } } @keyframes play { 0% { transform: rotateZ(0deg); } 100% { transform: rotateZ(-360deg); } } 12. 设置RSS 先安装 hexo-generator-feed 插件 npm install hexo-generator-feed --save 打开站点配置文件找到Extensions在下面添加 # RSS订阅 feed: type: atom path: atom.xml limit: 20 hub: content: content_limit: 140 content_limit_delim: ' ' 打开主题配置文件找到rss，设置为 rss: /atom.xml 13. 在网站底部加上访问量 添加是否开启统计功能的配置 找到next主题的配置文件themes/next/_config.yml footer: # ------------------------------------------------------------- # visitors count counter: true 修改next主题的模板文件theme/next/layout/_partials/footer.swig,我们在合适的位置加入： &lt;!-- 在网站底部加上访问量和字数 --> {% if theme.footer.counter %} &lt;script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">&lt;/script> &lt;span class="site-pv" title="总访问量"> &lt;i class="fa fa-eye">&lt;/i> &lt;span class="busuanzi-value" id="busuanzi_container_site_pv">总访问量：&lt;span id="busuanzi_value_site_pv">&lt;/span>次&lt;/span> &lt;/span> &lt;span class="post-meta-divider">|&lt;/span> &lt;span class="site-uv-md" title="总访客"> &lt;i class="fa fa-user">&lt;/i> &lt;span class="busuanzi-value" id="busuanzi_container_site_uv">总访客：&lt;span id="busuanzi_value_site_uv">&lt;/span>人&lt;/span> &lt;/span> &lt;span class="post-meta-divider">|&lt;/span> {% endif %} 不蒜子有两种统计方法： pv的方式，单个用户连续点击n篇文章，记录n次访问量 &lt;span id="busuanzi_container_site_pv"> 总访问量： &lt;span id="busuanzi_value_site_pv">&lt;/span> 次 &lt;/span> uv的方式，单个用户连续点击n篇文章，只记录1次访客数 &lt;span id="busuanzi_container_site_uv"> 总访客： &lt;span id="busuanzi_value_site_uv">&lt;/span> 人 &lt;/span> 14. 添加热度、本文字数和阅读时长 /themes/next/layout/_macro/post.swig: &lt;span class="busuanzi-value" id="busuanzi_value_page_pv" >&lt;/span> &lt;span>℃&lt;/span> 2 ./themes/next/languages/zh-CN.yml post: views: 热度 安装插件: npm install hexo-symbols-count-time --save 在全局配置文件中添加: symbols_count_time: symbols: true time: true 15. 网站底部字数统计1.安装插件: npm install hexo-wordcount --save 2.在/themes/next/layout/_partials/footer.swig文件尾部加上： &lt;div class="theme-info"> &lt;i class="fa fa-pencil">&lt;/i> &lt;span class="post-count">博客全站共{{ totalcount(site) }}字&lt;/span> &lt;/div> 3.文章字数统计:在主题的配置文件中，配置如下： # Post wordcount display settings # Dependencies: https://github.com/willin/hexo-wordcount post_wordcount: item_text: true wordcount: true min2read: true 16. 添加顶部加载条 在/themes/next/layout/_partials/head.swig中添加代码: &lt;script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js">&lt;/script> &lt;link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet"> 但是，默认的是粉色的，要改变颜色可以在/themes/next/layout/_partials/head.swig文件中添加如下代码（接在刚才link的后面） &lt;style> .pace .pace-progress { background: #1E92FB; /*进度条颜色*/ height: 3px; } .pace .pace-progress-inner { box-shadow: 0 0 10px #1E92FB, 0 0 5px #1E92FB; /*阴影颜色*/ } .pace .pace-activity { border-top-color: #1E92FB; /*上边框颜色*/ border-left-color: #1E92FB; /*左边框颜色*/ } &lt;/style> 现在升级最新版的next主题，升级后只需修改主题配置文件(_config.yml)将pace: false改为pace: true就行了，你还可以换不同样式的加载条， pace: true pace_theme: pace-theme-minimal 将模块安装到themes/next/source/lib/pace目录： git clone https://github.com/theme-next/theme-next-pace themes/next/source/lib/pace 17. 在右上角或者左上角实现fork me on github在http://tholman.com/github-corners/挑选自己喜欢的样式，并复制代码然后粘贴刚才复制的代码到themes/next/layout/_layout.swig文件中(放在的下面)，并把href改为你的github地址 18. 博文压缩 安装插件: npm install gulp -g npm install gulp-minify-css gulp-uglify gulp-htmlmin gulp-htmlclean gulp --save 在根目录新建gulpfile.js ，并填入以下内容： var gulp = require('gulp'); var minifycss = require('gulp-minify-css'); var uglify = require('gulp-uglify'); var htmlmin = require('gulp-htmlmin'); var htmlclean = require('gulp-htmlclean'); // 压缩 public 目录 css gulp.task('minify-css', function() { return gulp.src('./public/**/*.css') .pipe(minifycss()) .pipe(gulp.dest('./public')); }); // 压缩 public 目录 html gulp.task('minify-html', function() { return gulp.src('./public/**/*.html') .pipe(htmlclean()) .pipe(htmlmin({ removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, })) .pipe(gulp.dest('./public')) }); // 压缩 public/js 目录 js gulp.task('minify-js', function() { return gulp.src('./public/**/*.js') .pipe(uglify()) .pipe(gulp.dest('./public')); }); // 执行 gulp 命令时执行的任务 gulp.task('default', [ 'minify-html','minify-css','minify-js' ]); 生成博文是执行 hexo g &amp;&amp; gulp 就会根据 gulpfile.js 中的配置，对 public 目录中的静态资源文件进行压缩。 19. DaoVoice实现在线联系1.在http://www.daovoice.io/注册用户,需要邀请码: a43e7bc3 复制粘贴就可以了~! 2.在hexo\themes\next\layout_partials\head\head.swig添加下面的代码: {% if theme.daovoice %} &lt;script>(function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/a43e7bc3.js","daovoice") daovoice('init', { app_id: "{{theme.daovoice_app_id}}" }); daovoice('update'); &lt;/script> {% endif %} 在主题配置文件中添加: # daovoice在线联系 daovoice: true daovoice_app_id: 你的daovoice应用app_id 安装成功后可以在DaoVoice控制台上的聊天设置里设置聊天窗口样式，附上我的设置: 距离右侧像素值：20.0 距离下侧像素值：80.0 20. 添加分享功能主题配置文件添加: baidushare: type: button baidushare: true 代码在: /hexo/themes/next/layout/_macro/post.swig 21. 添加评论功能 打开LeanCloud官网 https://leancloud.cn 注册用户 修改主题配置文件: valine: enable: true appid: 你的LeanCloud应用appid appkey: 你的LeanCloud应用appkey notify: false # mail notifier , https://github.com/xCss/Valine/wiki verify: false # Verification code placeholder: 老铁，你不想说两句吗? avatar: wavatar guest_info: nick,mail,link pageSize: 10 22. 添加侧边栏友情链接修改主题配置文件： # Blog rolls links_icon: link links_title: 友情链接 # links_layout: block links_layout: inline links: Web前端导航: http://www.alloyteam.com/nav/ 创造狮导航: http://www.chuangzaoshi.com/code 前端书籍资料: http://www.36zhen.com/t?id=3448 掘金酱: http://e.xitu.io/ V2EX: https://www.v2ex.com/ 印记中文: https://www.v2ex.com/ 23. 添加侧边栏社交链接在图标库 https://fontawesome.com/icons 选择图标,修改主题配置文件： social: GitHub: https://github.com/yuanzi222 || github E-Mail: mailto:yuanzi_222@126.com || envelope 24. 设置首页不显示全文(只显示预览)修改主题配置文件: auto_excerpt: enable: true length: 150 25. SEO优化 首先给你的文章生成sitemap文件 npm install hexo-generator-sitemap --save #sitemap.xml适合提交给谷歌搜素引擎 npm install hexo-generator-baidu-sitemap --save #baidusitemap.xml适合提交百度搜索引擎 然后在站点配置文件_config.yml中添加以下代码 # 自动生成sitemap sitemap: path: sitemap.xml baidusitemap: path: baidusitemap.xml 优化结构 seo搜索引擎优化认为，网站的最佳结构是用户从首页点击三次就可以到达任何一个页面，但是我们使用hexo编译的站点打开文章的url是：sitename/year/mounth/day/title四层的结构，这样的url结构很不利于seo，爬虫就会经常爬不到我们的文章，于是，我们可以将url直接改成sitename/title的形式，并且title最好是用英文，在根目录的配置文件下修改permalink如下： url: http://你的网站 root: / permalink: :title.html permalink_defaults: nofollow标签 给非友情链接的出站链接添加 “nofollow” 标签，nofollow标签是由谷歌领头创新的一个“反垃圾链接”的标签，并被百度、yahoo等各大搜索引擎广泛支持，引用nofollow标签的目的是：用于指示搜索引擎不要追踪（即抓取）网页上的带有nofollow属性的任何出站链接，以减少垃圾链接的分散网站权重。 安装nofollow插件: npm install hexo-autonofollow --save 站点配置文件_config.yml添加: nofollow: enable: true exclude: - yuanzi.com robots.txt文件 在source文件夹中新建文件robots.txt: # hexo robots.txt User-agent: * Allow: / Allow: /archives/ Disallow: /vendors/ Disallow: /js/ Disallow: /css/ Disallow: /fonts/ Disallow: /vendors/ Disallow: /fancybox/ Sitemap: https://www.yuanzi222.com/sitemap.xml Sitemap: https://www.yuanzi222.com/baidusitemap.xml 验证网证 我们到百度站长平台 https://ziyuan.baidu.com/dashboard/index 里面的站长工具里面去验证网站，大概步骤如下： 第一步：输入网站 第二步：站点属性 第三步：验证网站 前两步都很简单，第三步：验证网站有以下三种方法： 文件验证 HTML标签验证 CNAME验证 这里我们选择CNAME验证的方法，加一条解析 链接提交 链接提交有手动和自动两种方法，手动就是每次你有新的链接生成，你就需要手动提交链接到百度，这种方法太麻烦了，不使用。 自动提交有三种方式： 主动推送(实时) 自动推送 sitemap 这里我们选择sitemap方式。 安装hexo的sitemap网站地图生成插件: npm install hexo-generator-baidu-sitemap --save 在你的hexo站点的_config.yml添加下面的代码 # hexo sitemap网站地图 baidusitemap: path: baidusitemap.xml 配置成功后，hexo编译时会在hexo站点根目录生成baidusitemap.xml，部署网站后，提交到百度： 26. 文章置顶+置顶标签 目前已经有修改后支持置顶的仓库，可以直接用以下命令安装。 npm uninstall hexo-generator-index --save npm install hexo-generator-index-pin-top --save 然后在需要置顶的文章的Front-matter中加上top: true即可。比如下面这篇文章： --- title: 使用Hexo+Github一步步搭建属于自己的博客 date: 2018-07-21 11:26:12 categories: hexo tags: [hexo] top: true --- 设置置顶标志 打开：/blog/themes/next/layout/_macro 目录下的post.swig文件，定位到标签下，插入如下代码： {% if post.top %} &lt;i class="fa fa-thumb-tack">&lt;/i> &lt;font color="7D26CD">置顶&lt;/font> &lt;span class="post-meta-divider">|&lt;/span> {% endif %} 27. 设置skip_render,指定不进行渲染的文件skip_render: - google74022f6cb5756d17.htm]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
